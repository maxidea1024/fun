#include "CorePrivatePCH.h"
#include "HAL/FSManagerGeneric.h"
//#include "Misc/SecureHash.h"
#include <time.h>

namespace fun {

DEFINE_LOG_CATEGORY_STATIC(LogFileManager, Info, All);

#define COPYBLOCKSIZE 32768

void FSManagerGeneric::ProcessCommandLineOptions() {
#if !(FUN_BUILD_SHIPPING || FUN_BUILD_TEST)
  if (Parse::Param(CommandLine::Get(), "CLEANSCREENSHOTS")) {
    DeleteDirectory(*CPaths::ScreenShotDir(), false, true);
  }

  if (Parse::Param(CommandLine::Get(), "CLEANLOGS")) {
    DeleteDirectory(*CPaths::GameLogDir(), false, true);
  }
#endif
}

Archive* FSManagerGeneric::CreateFileReader(const char* filename,
                                            FileReadFlags flags) {
  IFile* handle =
      GetLowLevel().OpenRead(filename, !!(flags & FileReadFlag::AllowWrite));
  if (handle == nullptr) {
    if (!!(flags & FileReadFlag::NoFail)) {
      fun_log(LogFileManager, Fatal, "Failed to read file: %s", filename);
    }
    return nullptr;
  }
  return new ArchiveFileReaderGeneric(handle, filename, handle_->Size());
}

/**
 * Dummy archive that doesn't actually write anything
 * it just updates the file pos when seeking
 */
class ArchiveFileWriterDummy : public Archive {
 public:
  ArchiveFileWriterDummy() : pos_(0) { ArIsSaving = ArIsPersistent = true; }

  // Archive interface
  virtual ~ArchiveFileWriterDummy() { Close(); }
  void Seek(int64 new_pos) override { pos_ = new_pos; }
  int64 Tell() override { return pos_; }
  void Serialize(void* v, int64 len) override { pos_ += len; }
  String GetArchiveName() const override { return "ArchiveFileWriterDummy"; }

 protected:
  int64 pos_;
};

Archive* FSManagerGeneric::CreateFileWriter(const char* filename,
                                            FileWriteFlags flags) {
  // Only allow writes to files that are not signed
  // Except if the file is missing(that way corrupt ini files can be
  // autogenerated by deleting them)
  // TODO?
  // if (CSHA1::GetFileSHAHash(filename, nullptr) && FileSize(filename) != -1) {
  //  fun_log(LogFileManager, Info, "Can't write to signed game file: %s",
  //  filename); return new ArchiveFileWriterDummy();
  //}
  MakeDirectory(*CPaths::GetPath(filename), true);

  if (!!(flags & FileWriteFlag::EvenIfReadOnly)) {
    GetLowLevel().SetReadOnly(filename, false);
  }

  IFile* handle =
      GetLowLevel().OpenWrite(filename, !!(flags & FileWriteFlag::Append),
                              !!(flags & FileWriteFlag::AllowRead));
  if (handle == nullptr) {
    if (!!(flags & FileWriteFlag::NoFail)) {
      fun_log(LogFileManager, Fatal, TEXT("Failed to create file: %s"),
              filename);
    }
    return nullptr;
  }
  return new ArchiveFileWriterGeneric(handle, filename, handle_->Tell());
}

int64 FSManagerGeneric::FileSize(const char* filename) {
  return GetLowLevel().FileSize(filename);
}

FileCopyResult FSManagerGeneric::Copy(
    const char* dest_file, const char* src_file, bool replace_existing,
    bool event_if_read_only, bool copy_attributes, FileCopyProgress* progress) {
  FileCopyResult result = FileCopyResult::OK;
  if (CPaths::ConvertRelativePathToFull(dest_file) ==
      CPaths::ConvertRelativePathToFull(src_file)) {
    result = FileCopyResult::Fail;
  } else if (progress) {
    result = CopyWithProgress(dest_file, src_file, replace_existing,
                              event_if_read_only, copy_attributes, progress);
  } else if (!replace_existing && GetLowLevel().FileExists(dest_file)) {
    result = FileCopyResult::Fail;
  } else {
    if (event_if_read_only) {
      GetLowLevel().SetReadOnly(dest_file, false);
    }
    MakeDirectory(*CPaths::GetPath(dest_file), true);
    if (!GetLowLevel().CopyFile(dest_file, src_file)) {
      result = FileCopyResult::Fail;
    }
  }

  // Restore read-only attribute if required
  if (result == FileCopyResult::OK && copy_attributes) {
    GetLowLevel().SetReadOnly(dest_file, GetLowLevel().IsReadOnly(src_file));
  }

  return result;
}

FileCopyResult FSManagerGeneric::CopyWithProgress(
    const char* dest_file, const char* src_file, bool replace_existing,
    bool event_if_read_only, bool copy_attributes, FileCopyProgress* progress) {
  FileCopyResult result = FileCopyResult::OK;

  // Direct file copier.
  if (progress == nullptr || progress->Poll(0.0)) {
    String SrcFile = src_file;
    String DestFile = dest_file;

    Archive* src = CreateFileReader(*SrcFile);
    if (src == nullptr) {
      result = FileCopyResult::Fail;
    } else {
      FileWriteFlags write_flags;
      if (replace_existing) write_flags |= FileWriteFlag::NoReplaceExisting;
      if (event_if_read_only) write_flags |= FileWriteFlag::EvenIfReadOnly;
      Archive* dst = CreateFileWriter(*DestFile, write_flags);
      if (dst == nullptr) {
        result = FileCopyResult::Fail;
      } else {
        int64 size = src->TotalSize();
        int64 Percent = 0, new_percent = 0;
        uint8* Buffer = new uint8[COPYBLOCKSIZE];
        for (int64 Total = 0; Total < size; Total += sizeof(Buffer)) {
          int64 Count = MathBase::Min(size - Total, (int64)sizeof(Buffer));
          src->Serialize(Buffer, Count);
          if (src->IsError()) {
            result = FileCopyResult::Fail;
            break;
          }
          dst->Serialize(Buffer, Count);
          if (dst->IsError()) {
            result = FileCopyResult::Fail;
            break;
          }
          new_percent = Total * 100 / size;
          if (progress != nullptr && Percent != new_percent &&
              !progress->Poll((float)new_percent / 100.f)) {
            result = FileCopyResult::Canceled;
            break;
          }
          Percent = new_percent;
        }
        delete[] Buffer;
        if (result == FileCopyResult::OK && !dst->Close()) {
          result = FileCopyResult::Fail;
        }
        delete dst;
        if (result != FileCopyResult::OK) {
          Delete(*DestFile);
        }
      }
      if (result == FileCopyResult::OK && !src->Close()) {
        result = FileCopyResult::Fail;
      }
      delete src;
    }
    if (progress != nullptr && result == FileCopyResult::OK &&
        !progress->Poll(1.0)) {
      result = FileCopyResult::Canceled;
    }
  } else {
    result = FileCopyResult::Canceled;
  }

  return result;
}

bool FSManagerGeneric::Delete(const char* filename, bool require_exists,
                              bool event_if_read_only, bool quiet) {
  // Only allow writes to files that are not signed
  // Except if the file is missing(that way corrupt ini files can be
  // autogenerated by deleting them)
  // TODO?
  // if (CSHA1::GetFileSHAHash(filename, nullptr)) {
  //  if (!quiet) {
  //    fun_log(LogFileManager, Info, TEXT("Can't delete signed game file: %s"),
  //    filename);
  //  }
  //  return false;
  //}

  const bool exists = GetLowLevel().FileExists(filename);
  if (require_exists && !exists) {
    if (!quiet) {
      fun_log(LogFileManager, Warning,
              "Could not delete %s because it doesn't exist.", filename);
    }
    return false;
  }

  if (exists) {
    if (event_if_read_only) {
      GetLowLevel().SetReadOnly(filename, false);
    }

    if (!GetLowLevel().DeleteFile(filename)) {
      if (!quiet) {
        fun_log(LogFileManager, Warning,
                "Error deleting file: %s (Error Code %i)", filename,
                PlatformMisc::GetLastError());
      }
      return false;
    }
  }

  return true;
}

bool FSManagerGeneric::IsReadOnly(const char* filename) {
  return GetLowLevel().IsReadOnly(filename);
}

bool FSManagerGeneric::Move(const char* dst, const char* src, bool replace,
                            bool event_if_read_only, bool copy_attributes,
                            bool do_not_retry_or_error) {
  MakeDirectory(*CPaths::GetPath(dst), true);

  // Retry on failure, unless the file wasn't there anyway.
  if (GetLowLevel().FileExists(dst) && !GetLowLevel().DeleteFile(dst) &&
      !do_not_retry_or_error) {
    // If the delete failed, throw a warning but retry before we throw an error
    fun_log(LogFileManager, Warning,
            TEXT("DeleteFile was unable to delete '%s', retrying in .5s..."),
            dst);

    // Wait just a little bit(i.e. a totally arbitrary amount)...
    CPlatformProcess::Sleep(0.5f);

    // Try again
    if (!GetLowLevel().DeleteFile(dst)) {
      fun_log(LogFileManager, Error, TEXT("Error deleting file '%s'."), dst);
      return false;
    } else {
      fun_log(LogFileManager, Warning,
              TEXT("DeleteFile recovered during retry!"));
    }
  }

  if (!GetLowLevel().MoveFile(dst, src)) {
    if (do_not_retry_or_error) {
      return false;
    }

    int32 RetryCount = 10;
    bool success = false;
    while (RetryCount--) {
      // If the move failed, throw a warning but retry before we throw an error
      fun_log(
          LogFileManager, Warning,
          TEXT("MoveFile was unable to move '%s' to '%s', retrying in .5s..."),
          src, dst);

      // Wait just a little bit(i.e. a totally arbitrary amount)...
      CPlatformProcess::Sleep(0.5f);

      // Try again
      success = GetLowLevel().MoveFile(dst, src);
      if (success) {
        fun_log(LogFileManager, Warning,
                TEXT("MoveFile recovered during retry!"));
        break;
      }
    }
    if (!success) {
      fun_log(LogFileManager, Error, TEXT("Error moving file '%s' to '%s'."),
              src, dst);
      return false;
    }
  }
  return true;
}

bool FSManagerGeneric::FileExists(const char* filename) {
  return GetLowLevel().FileExists(filename);
}

bool FSManagerGeneric::DirectoryExists(const char* directory) {
  return GetLowLevel().DirectoryExists(directory);
}

bool FSManagerGeneric::MakeDirectory(const char* path, bool tree) {
  if (tree) {
    return GetLowLevel().CreateDirectoryTree(path);
  } else {
    return GetLowLevel().CreateDirectory(path);
  }
}

bool FSManagerGeneric::DeleteDirectory(const char* path, bool require_exists,
                                       bool tree) {
  if (tree) {
    return GetLowLevel().DeleteDirectoryRecursively(path) ||
           (!require_exists && !GetLowLevel().DirectoryExists(path));
  }
  return GetLowLevel().DeleteDirectory(path) ||
         (!require_exists && !GetLowLevel().DirectoryExists(path));
}

FileStatData FSManagerGeneric::GetStatData(const char* filename_or_directory) {
  return GetLowLevel().GetStatData(filename_or_directory);
}

void FSManagerGeneric::FindFiles(Array<String>& result, const char* InFilename,
                                 bool with_files, bool with_directories) {
  struct CFileMatch : public IPlatformFS::DirectoryVisitor {
    Array<String>& result;
    String wildcard;
    bool with_files;
    bool with_directories;

    CFileMatch(Array<String>& result, const String& wildcard, bool with_files,
               bool with_directories)
        : result(result),
          wildcard(wildcard),
          with_files(with_files),
          with_directories(with_directories) {}

    virtual bool Visit(const char* filename_or_directory, bool is_directory) {
      if (((is_directory && with_directories) ||
           (!is_directory && with_files)) &&
          CPaths::GetCleanFilename(filename_or_directory).GlobMatch(wildcard)) {
        new (result) String(CPaths::GetCleanFilename(filename_or_directory));
      }
      return true;
    }
  };

  String filename(InFilename);
  CPaths::NormalizeFilename(filename);
  const String clean_filename = CPaths::GetCleanFilename(filename);
  const bool find_all_files =
      clean_filename == TEXT("*") || clean_filename == TEXT("*.*");
  CFileMatch file_match(result, find_all_files ? TEXT("*") : clean_filename,
                        with_files, with_directories);
  GetLowLevel().IterateDirectory(*CPaths::GetPath(filename), file_match);
}

//@maxidea: todo: TEXT로 안묶었는데, 이거 괜시리 인코딩 변환이 이루어지는거
//아닌가??
void FSManagerGeneric::FindFiles(Array<String>& out_found_files,
                                 const char* directory,
                                 const char* file_extension) {
  if (directory == nullptr) {
    return;
  }

  String root_dir(directory);
  String ext_str = file_extension ? String(file_extension) : "";

  // No directory?
  if (root_dir.Len() < 1) {
    return;
  }

  CPaths::NormalizeDirectoryName(root_dir);

  // Don't modify the ext_str if the user supplied the form "*.EXT" or "*" or
  // "*.*" or "Name.*"
  if (!ext_str.Contains("*")) {
    if (ext_str == "") {
      ext_str = "*.*";
    } else {
      // Complete the supplied extension with * or *. to yield "*.EXT"
      ext_str = (ext_str.Left(1) == ".") ? "*" + ext_str : "*." + ext_str;
    }
  }

  // Create the full filter, which is "directory/*.EXT".
  String final_path = root_dir + "/" + ext_str;
  FindFiles(out_found_files, *final_path, true, false);
}

bool FSManagerGeneric::IterateDirectory(
    const char* directory, IPlatformFS::DirectoryVisitor& visitor) {
  return GetLowLevel().IterateDirectory(directory, visitor);
}

bool FSManagerGeneric::IterateDirectoryRecursively(
    const char* directory, IPlatformFS::DirectoryVisitor& visitor) {
  return GetLowLevel().IterateDirectoryRecursively(directory, visitor);
}

bool FSManagerGeneric::IterateDirectoryStat(
    const char* directory, IPlatformFS::DirectoryStatVisitor& visitor) {
  return GetLowLevel().IterateDirectoryStat(directory, visitor);
}

bool FSManagerGeneric::IterateDirectoryStatRecursively(
    const char* directory, IPlatformFS::DirectoryStatVisitor& visitor) {
  return GetLowLevel().IterateDirectoryStatRecursively(directory, visitor);
}

double FSManagerGeneric::GetFileAgeSeconds(const char* filename) {
  // make sure it exists
  if (!GetLowLevel().FileExists(filename)) {
    return -1.0;
  }
  // get difference in time between now (UTC) and the filetime
  const Timespan age = DateTime::UtcNow() - GetTimestamp(filename);
  return age.TotalSeconds();
}

DateTime FSManagerGeneric::GetTimestamp(const char* filename) {
  // ask low level for timestamp
  return GetLowLevel().GetTimestamp(filename);
}

void FSManagerGeneric::GetTimestampPair(const char* path_a, const char* path_b,
                                        DateTime& out_timestamp_a,
                                        DateTime& out_timestamp_b) {
  GetLowLevel().GetTimestampPair(path_a, path_b, out_timestamp_a,
                                 out_timestamp_b);
}

bool FSManagerGeneric::SetTimestamp(const char* filename,
                                    const DateTime& timestamp) {
  // if the file doesn't exist, fail
  if (!GetLowLevel().FileExists(filename)) {
    return false;
  }

  GetLowLevel().SetTimestamp(filename, timestamp);
  return true;
}

DateTime FSManagerGeneric::GetAccessTimestamp(const char* filename) {
  // ask low level for timestamp
  return GetLowLevel().GetAccessTimestamp(filename);
}

String FSManagerGeneric::GetFilenameOnDisk(const char* filename) {
  return GetLowLevel().GetFilenameOnDisk(filename);
}

String FSManagerGeneric::DefaultConvertToRelativePath(const char* filename) {
  // default to the full absolute path of this file
  String relative_path(filename);
  CPaths::NormalizeFilename(relative_path);

  // See whether it is a relative path.
  String root_directory(PlatformMisc::root_dir());
  CPaths::NormalizeFilename(root_directory);

  // the default relative directory it to the app root which is 3 directories up
  // from the starting directory
  int32 num_directories_to_go_up = 3;

  // temp holder for current position of the slash
  int32 current_slash_pos;

  // while we haven't run out of parent directories until we which a drive name
  while ((current_slash_pos = root_directory.LastIndexOf(
              "/", CaseSensitivity::CaseSensitive)) != INVALID_INDEX) {
    if (relative_path.StartsWith(root_directory)) {
      String binaries_dir = String(CPlatformProcess::BaseDir());
      CPaths::MakePathRelativeTo(relative_path, *binaries_dir);
      break;
    }

    const int32 pos_of_next_slash = root_directory.LastIndexOf(
        "/", CaseSensitivity::CaseSensitive, current_slash_pos);
    // if there is another slash to find
    if (pos_of_next_slash != INVALID_INDEX) {
      // move up a directory and on an extra .. TEXT("/")
      // the +1 from "InStr" moves to include the "\" at the end of the
      // directory name
      num_directories_to_go_up++;
      root_directory = root_directory.Left(pos_of_next_slash + 1);
    } else {
      root_directory.Clear();
    }
  }
  return relative_path;
}

String FSManagerGeneric::ConvertToRelativePath(const char* filename) {
  return DefaultConvertToRelativePath(filename);
}

String FSManagerGeneric::ConvertToAbsolutePathForExternalAppForRead(
    const char* absolute_path) {
  return GetLowLevel().ConvertToAbsolutePathForExternalAppForRead(
      absolute_path);
}

String FSManagerGeneric::ConvertToAbsolutePathForExternalAppForWrite(
    const char* absolute_path) {
  return GetLowLevel().ConvertToAbsolutePathForExternalAppForWrite(
      absolute_path);
}

void FSManagerGeneric::FindFilesRecursive(Array<String>& out_filenames,
                                          const char* start_directory,
                                          const char* filename, bool with_files,
                                          bool with_directories,
                                          bool clear_filenames) {
  if (clear_filenames) {
    out_filenames.Clear();
  }
  FindFilesRecursiveInternal(out_filenames, start_directory, filename,
                             with_files, with_directories);
}

void FSManagerGeneric::FindFilesRecursiveInternal(Array<String>& out_filenames,
                                                  const char* start_directory,
                                                  const char* filename,
                                                  bool with_files,
                                                  bool with_directories) {
  String current_search = String(start_directory) / filename;
  Array<String> result;
  FindFiles(result, *current_search, with_files, with_directories);

  for (int32 i = 0; i < result.Count(); ++i) {
    out_filenames.Add(String(start_directory) / result[i]);
  }

  Array<String> sub_dirs;
  String recursive_dir_search = String(start_directory) / "*";
  FindFiles(sub_dirs, *recursive_dir_search, false, true);

  for (int32 sub_dir_index = 0; sub_dir_index < sub_dirs.Count();
       ++sub_dir_index) {
    String sub_dir = String(start_directory) / sub_dirs[sub_dir_index];
    FindFilesRecursiveInternal(out_filenames, *sub_dir, filename, with_files,
                               with_directories);
  }
}

//
// ArchiveFileReaderGeneric
//

ArchiveFileReaderGeneric::ArchiveFileReaderGeneric(IFile* handle,
                                                   const char* filename,
                                                   int64 size)
    : filename_(filename),
      size_(size),
      pos_(0),
      buffer_base_(0),
      buffer_count_(0),
      handle_(handle) {
  ArIsLoading = ArIsPersistent = true;
}

void ArchiveFileReaderGeneric::Seek(int64 new_pos) {
  fun_check_msg(new_pos >= 0,
                TEXT("Attempted to seek to a negative location (%lld/%lld), "
                     "file: %s. The file is most likely corrupt."),
                new_pos, size_, *filename_);
  fun_check_msg(new_pos <= size_,
                TEXT("Attempted to seek past the end of file (%lld/%lld), "
                     "file: %s. The file is most likely corrupt."),
                new_pos, size_, *filename_);
  if (!SeekLowLevel(new_pos)) {
    char error_msg[1024];
    ArIsError = true;
    fun_log(LogFileManager, Error,
            TEXT("SetFilePointer on %s Failed %lld/%lld: %lld %s"), *filename,
            new_pos, size_, pos_,
            PlatformMisc::GetSystemErrorMessage(error_msg, 1024, 0));
  }
  pos_ = new_pos;
  buffer_base_ = pos_;
  buffer_count_ = 0;
}

ArchiveFileReaderGeneric::~ArchiveFileReaderGeneric() { Close(); }

void ArchiveFileReaderGeneric::ReadLowLevel(uint8* dst, int64 len_to_read,
                                            int64& out_readed_len) {
  if (handle_->Read(dst, len_to_read)) {
    out_readed_len = len_to_read;
  } else {
    out_readed_len = 0;
  }
}

bool ArchiveFileReaderGeneric::SeekLowLevel(int64 new_pos) {
  return handle_->Seek(new_pos);
}

void ArchiveFileReaderGeneric::CloseLowLevel() { handle_.Reset(); }

bool ArchiveFileReaderGeneric::Close() {
  CloseLowLevel();
  return !ArIsError;
}

bool ArchiveFileReaderGeneric::InternalPrecache(int64 precache_offset,
                                                int64 precache_size) {
  // Only precache at current position and avoid work if precaching same offset
  // twice.
  if (pos_ == precache_offset &&
      (buffer_base_ == 0 || buffer_count_ == 0 || buffer_base_ != pos_)) {
    buffer_base_ = pos_;
    buffer_count_ = MathBase::Min(
        MathBase::Min(precache_size, (int64)(countof(buffer_) -
                                             (pos_ & (countof(buffer_) - 1)))),
        size_ - pos_);
    buffer_count_ = MathBase::Max(buffer_count_, 0LL);  // clamp to 0
    int64 count = 0;

    // Read data from device via Win32 ReadFile API.
    {
      CLOG(buffer_count_ > countof(buffer_) || buffer_count_ <= 0,
           LogFileManager, Fatal,
           "Invalid buffer_count_=%lld while reading %s. File is most likely "
           "corrupted, try deleting it if possible. Pos=%lld, Size=%lld, "
           "precache_size=%lld, precache_offset=%lld",
           buffer_count_, *filename, pos_, size_, precache_size,
           precache_offset);

      ReadLowLevel(buffer_, buffer_count_, count);
    }

    if (count != buffer_count_) {
      char error_msg[1024];
      ArIsError = true;
      fun_log(LogFileManager, Warning,
              TEXT("ReadFile failed: Count=%lld buffer_count_=%lld Error=%s"),
              count, buffer_count_,
              PlatformMisc::GetSystemErrorMessage(error_msg, 1024, 0));
    }
  }
  return true;
}

void ArchiveFileReaderGeneric::Serialize(void* v, int64 len) {
  while (len > 0) {
    int64 len_to_copy = MathBase::Min(len, buffer_base_ + buffer_count_ - pos_);
    if (len_to_copy <= 0) {
      if (len >= countof(buffer_)) {
        int64 count = 0;
        { ReadLowLevel((uint8*)v, Length, count); }
        if (count != len) {
          char error_msg[1024];
          ArIsError = true;
          fun_log(
              LogFileManager, Warning,
              "ReadFile failed: Count=%lld Length=%lld Error=%s for file %s",
              count, len,
              PlatformMisc::GetSystemErrorMessage(error_msg, 1024, 0),
              *filename);
        }
        pos_ += len;
        return;
      }

      InternalPrecache(pos_, int32_MAX);

      len_to_copy = MathBase::Min(len, buffer_base_ + buffer_count_ - pos_);
      if (len_to_copy <= 0) {
        ArIsError = true;
        fun_log(LogFileManager, Error,
                "ReadFile beyond EOF %lld+%lld/%lld for file %s", pos_, len,
                size_, *filename);
      }

      if (ArIsError) {
        return;
      }
    }

    UnsafeMemory::Memcpy(v, Buffer + pos_ - buffer_base_, len_to_copy);
    pos_ += len_to_copy;
    len -= len_to_copy;
    v = (uint8*)v + len_to_copy;
  }
}

//
// ArchiveFileWriterGeneric
//

ArchiveFileWriterGeneric::ArchiveFileWriterGeneric(IFile* handle,
                                                   const char* filename,
                                                   int64 pos)
    : filename_(filename),
      pos_(pos),
      buffer_count_(0),
      handle_(handle),
      is_logging_error_(false) {
  ArIsSaving = ArIsPersistent = true;
}

ArchiveFileWriterGeneric::~ArchiveFileWriterGeneric() { Close(); }

bool ArchiveFileWriterGeneric::CloseLowLevel() {
  handle_.Reset();
  return true;
}

bool ArchiveFileWriterGeneric::SeekLowLevel(int64 new_pos) {
  return handle_->Seek(new_pos);
}

int64 ArchiveFileWriterGeneric::TotalSize() {
  // Make sure that all data is written before looking at file size.
  Flush();
  return handle_->Size();
}

bool ArchiveFileWriterGeneric::WriteLowLevel(const uint8* src,
                                             int64 len_to_write) {
  return handle_->Write(src, len_to_write);
}

void ArchiveFileWriterGeneric::Seek(int64 new_pos) {
  Flush();

  if (!SeekLowLevel(new_pos)) {
    ArIsError = true;
    LogWriteError("Error seeking file");
  }

  pos_ = new_pos;
}

bool ArchiveFileWriterGeneric::Close() {
  Flush();

  if (!CloseLowLevel()) {
    ArIsError = true;
    LogWriteError("Error closing file");
  }

  return !ArIsError;
}

void ArchiveFileWriterGeneric::Serialize(void* v, int64 Length) {
  pos_ += len;

  if (len >= countof(Buffer)) {
    Flush();

    if (!WriteLowLevel((uint8*)v, len)) {
      ArIsError = true;
      LogWriteError("Error writing to file");
    }
  } else {
    int64 len_to_copy;
    while (len > (len_to_copy = countof(Buffer) - buffer_count_)) {
      UnsafeMemory::Memcpy(Buffer + buffer_count_, v, len_to_copy);
      buffer_count_ += len_to_copy;
      fun_check(buffer_count_ <= countof(Buffer) && buffer_count_ >= 0);
      len -= len_to_copy;
      v = (uint8*)v + len_to_copy;
      Flush();
    }

    if (len) {
      UnsafeMemory::Memcpy(Buffer + buffer_count_, v, len);
      buffer_count_ += len;
      fun_check(buffer_count_ <= countof(Buffer) && buffer_count_ >= 0);
    }
  }
}

void ArchiveFileWriterGeneric::Flush() {
  if (buffer_count_) {
    fun_check(buffer_count_ <= countof(Buffer) && buffer_count_ > 0);
    if (!WriteLowLevel(Buffer, buffer_count_)) {
      ArIsError = true;
      LogWriteError("Error flushing file");
    }
    buffer_count_ = 0;
  }
}

void ArchiveFileWriterGeneric::LogWriteError(const char* message) {
  // Prevent re-entry if logging causes another log error leading to a stack
  // overflow
  if (!is_logging_error_) {
    is_logging_error_ = true;
    char error_msg[1024];
    fun_log(LogFileManager, Error, "%s: %s (%s)", message, *filename,
            PlatformMisc::GetSystemErrorMessage(error_msg, 1024, 0));
    is_logging_error_ = false;
  }
}

IFileManager& IFileManager::Get() {
  static ScopedPtr<FSManagerGeneric> singleton;
  if (singleton == nullptr) {
    singleton = new FSManagerGeneric();
  }
  return *singleton;
}

}  // namespace fun
