//#include "CorePrivatePCH.h"
//#include "Misc/Parse.h"
//#include "Containers/lazy_printf.h"
//#include "Misc/FileHelper.h"

#include "fun/base/parse.h"
#include "fun/base/container/set.h"
#include "fun/base/string/string.h"
#include "fun/base/uuid.h"

namespace fun {

//#if !FUN_BUILD_SHIPPING
//
//class ConsoleCommandLibrary {
// public:
//  ConsoleCommandLibrary(const String& pattern);
//  ~ConsoleCommandLibrary();
//
//  void OnParseCommand(const char* match) {
//    // -1 to not take the "*" after the pattern into account
//    if (CStringTraitsA::Strnicmp(match, *pattern, pattern.Len() - 1) == 0) {
//      known_names.Add(match);
//    }
//  }
//
//  const String& pattern;
//  Set<String> known_names;
//};
//
//// 0 if gathering of names is deactivated
//ConsoleCommandLibrary* g_console_command_library;
//
//ConsoleCommandLibrary::ConsoleCommandLibrary(const String& pattern)
//  : pattern(pattern)
//{
//  // activate name gathering
//  g_console_command_library = this;
//}
//
//ConsoleCommandLibrary::~ConsoleCommandLibrary()
//{
//  // deactivate name gathering
//  g_console_command_library = nullptr;
//}
//
//
//class ConsoleVariableDumpVisitor
//{
// public:
//  // @param Name must not be 0
//  // @param " must not be 0
//  static void OnConsoleVariable(const char* name, IConsoleObject* cvar, Set<String>& sink) {
//    if(cvar->TestFlags(ECVF_Unregistered)) {
//      return;
//    }
//
//    sink.Add(name);
//  }
//};
//
//void ConsoleCommandLibrary_DumpLibrary(env* env, Exec& sub_system, const String& pattern, Printer& out)
//{
//  ConsoleCommandLibrary local_console_command_library(pattern);
//
//  PrinterNull Null;
//
//  const bool executed = sub_system.Exec(env, *pattern, Null);
//  {
//    IConsoleManager::Get().ForEachConsoleObject(
//        ConsoleObjectVisitor::CreateStatic<Set<String>&>(
//          &ConsoleVariableDumpVisitor::OnConsoleVariable,
//          local_console_command_library.known_names));
//  }
//
//  local_console_command_library.known_names.Sort( Less<String>() );
//
//  for (Set<String>::ConstIterator it(local_console_command_library.known_names); it; ++it) {
//    const String name = *it;
//
//    out.Printf("%s", *name);
//  }
//  out.Printf("");
//
//  // the pattern (e.g. Motion*) should not really trigger the execution
//  if (executed) {
//    out.Printf("ERROR: The function was supposed to only find matching commands but not have any side effect.");
//    out.Printf("However Exec() returned true which means we either executed a command or the command parsing returned true where it shouldn't.");
//  }
//}
//
//
//void ConsoleCommandLibrary_DumpLibraryHTML(env* env, Exec& sub_system, const String& out_path)
//{
//  const String& pattern("*");
//  ConsoleCommandLibrary local_console_command_library(pattern);
//
//  PrinterNull Null;
//
//  bool executed = sub_system.Exec(env, *local_console_command_library.pattern, Null);
//  {
//    IConsoleManager::Get().ForEachConsoleObject(
//      ConsoleObjectVisitor::CreateStatic<Set<String>&>(
//        &ConsoleVariableDumpVisitor::OnConsoleVariable,
//        local_console_command_library.known_names));
//  }
//
//  local_console_command_library.known_names.Sort(Less<String>());
//
//  String template_filename = CPaths::Combine(CPlatformProcess::BaseDir(), "../../Documentation/Extras", "ConsoleHelpTemplate.html");
//  String template_file;
//  if (FileHelper::ReadAllText(template_file, *template_filename,
//    FileHelper::HashOptions(FileHelper::HashOption::EnableVerify) | FileHelper::HashOption::ErrorMissingHash)) {
//    // todo: do we need to create the directory?
//    UniquePtr<Archive> file(IFileManager::Get().CreateDebugFileWriter(*out_path));
//    if (file.IsValid()) {
//      LazyPrintf lazy_printf(*template_file);
//
//      lazy_printf.PushParam("FUN Console Variables and Commands");    // title
//      lazy_printf.PushParam("FunConsole Variables and Commands");   // headline
//      lazy_printf.PushParam("FunConsole command 'Help'");           // generated by
//      lazy_printf.PushParam("0.95");                                  // version
//      lazy_printf.PushParam(*DateTime::Now().ToString());             // date
//
//      String all_data;
//
//      for (Set<String>::ConstIterator it(local_console_command_library.known_names); it; ++it) {
//        const String& name = *it;
//
//        auto element = IConsoleManager::Get().FindConsoleObject(*name);
//        if (element) {
//          // console command or variable
//
//          String help = element->GetHelp();
//          help = help.ReplaceCharWithEscapedChar();
//
//          const char* element_type = "Unknown";
//          if (element->AsVariable()) {
//            element_type = "Var";
//          } else if (Element->AsCommand()) {
//            element_type = "Cmd";
//          }
//
//          //{name: "r.SetRes", help:"To change the screen/window resolution."},
//          String data_line = String::Format("{name: \"%s\", help:\"%s\", type:\"%s\"},\r\n", *name, *help, element_type);
//          all_data += data_line;
//        } else {
//          // Exec command (better we change them to use the new method as it has better help and is more convenient to use)
//          //{name: "", help:"To change the screen/window resolution."},
//          String data_line = String::Format("{name: \"%s\", help:\"Sorry: Exec commands have no help\", type:\"Exec\"},\r\n", *name);
//          all_data += data_line;
//        }
//      }
//
//      lazy_printf.PushParam(*all_data);
//
//      auto AnsiHelp = StringCast<ANSICHAR>(*lazy_printf.GetResultString());
//      file->Serialize((ANSICHAR*)AnsiHelp.Get(), AnsiHelp.length());
//    }
//  }
//
///*
//  // the pattern (e.g. Motion*) should not really trigger the execution
//  if (executed) {
//    out.Printf("ERROR: The function was supposed to only find matching commands but not have any side effect.");
//    out.Printf("However Exec() returned true which means we either executed a command or the command parsing returned true where it shouldn't.");
//  }
//*/
//}
//
//#endif //#if !FUN_BUILD_SHIPPING


//TODO server에서 command line 명령을 처리할 수 있게 하는것도 나쁘지 않은듯...

//
// Parse
//

bool Parse::Value(const char* stream,
                  const char* match,
                  char* value,
                  int32 max_len,
                  bool should_stop_on_comma) {
  const char* found = CStringTraitsA::Strfind(stream, match);
  if (found == nullptr) {
    return false;
  }

  const char* start = found + CStringTraitsA::Strlen(match);

  // Check for quoted arguments' string with spaces
  // -Option="Value1 Value2"
  //         ^~~~start
  const bool is_arg_quoted = (*start == '"');

  // Number of characters we can look back from found looking for first parenthesis.
  const uint32 allowed_backtrace_char_count = (uint32)(found - stream);

  // Check for fully quoted string with spaces
  const bool is_fully_quoted =
    // "Option=Value1 Value2"
    //  ^~~~found
    (allowed_backtrace_char_count > 0 && found[-1] == '"')
    // "-Option=Value1 Value2"
    //   ^~~~found
    || (allowed_backtrace_char_count > 1 && (found[-1] == '-' && found[-2] == '"'));

  if (is_arg_quoted || is_fully_quoted) {
    // Skip quote character if only params were quoted.
    const int32 quotes_to_skip = is_arg_quoted ? 1 : 0;
    CStringTraitsA::Strncpy(value, start + quotes_to_skip, max_len);

    value[max_len-1] = 0;
    char* tmp = CStringTraitsA::Strstr(value, "\x22");
    if (tmp) {
      *tmp = 0;
    }
  } else {
    // Non-quoted string without spaces.
    CStringTraitsA::Strncpy(value, start, max_len);
    value[max_len - 1] = 0;
    char* tmp;
    tmp = CStringTraitsA::Strstr(value, " ");  if (tmp) *tmp = 0;
    tmp = CStringTraitsA::Strstr(value, "\r"); if (tmp) *tmp = 0;
    tmp = CStringTraitsA::Strstr(value, "\n"); if (tmp) *tmp = 0;
    tmp = CStringTraitsA::Strstr(value, "\t"); if (tmp) *tmp = 0;
    if (should_stop_on_comma) {
      tmp = CStringTraitsA::Strstr(value, ","); if (tmp) *tmp = 0;
    }
  }
  return true;
}

bool Parse::Param(const char* stream, const char* param_name) {
  if (*stream) {
    const char* start = stream;
    while ((start = CStringTraitsA::Strfind(start + 1, param_name))) {
      if (start > stream && (start[-1] == '-' || start[-1] == '/')) {
        const char* end = start + CStringTraitsA::Strlen(param_name);
        //TODO end가 null일수 있으려나??
        if (end == nullptr || *end == 0 || CharTraitsA::IsWhitespace(*end)) {
          return true;
        }
      }
    }
  }
  return false;
}

bool Parse::Value(const char* stream,
                  const char* match,
                  String& value,
                  bool should_stop_on_comma) {
  char buf[4096] = "";
  if (Parse::Value(stream, match, buf, countof(buf), should_stop_on_comma)) {
    value = buf;
    return true;
  } else {
    return false;
  }
}

bool Parse::QuotedString(const char* buffer, String& value, int32* readed_char_count) {
  if (readed_char_count) {
    *readed_char_count = 0;
  }

  const char* start = buffer;
  const char* ptr = buffer;

  // Require opening quote
  if (*ptr++ != '"') {
    return false;
  }

  while (*ptr && *ptr != '"' && *ptr != '\n' && *ptr != '\r') {
    if (*ptr != '\\') { // unescaped character
      value += *ptr++;
    } else if (*++ptr == '\\') { // escaped backslash "\\"
      value += "\\";
      ++ptr;
    } else if (*ptr == '\"') { // escaped double quote "\""
      value += '"';
      ++ptr;
    } else if (*ptr == '\'') { // escaped single quote "\'"
      value += '\'';
      ++ptr;
    } else if (*ptr == 'n') { // escaped newline
      value += '\n';
      ++ptr;
    } else if (*ptr == 'r') { // escaped carriage return
      value += '\r';
      ++ptr;
    } else { // some other escape sequence, assume it's a hex character value
      value += String::Format("%c", (HexDigit(ptr[0]) * 16) + HexDigit(ptr[1]));
      ptr += 2;
    }
  }

  // Require closing quote
  if (*ptr++ != '"') {
    return false;
  }

  if (readed_char_count) {
    *readed_char_count = (int32)(ptr - start);
  }

  return true;
}

bool Parse::Value(const char* stream, const char* match, uint64& value) {
  return Value(stream, match, *(int64*)&value);
}

bool Parse::Value(const char* stream, const char* match, int64& value) {
  char buf[4096] = "", *ptr = buf;
  if (Value(stream, match, buf, countof(buf))) {
    value = 0;

    const bool is_neg = (*ptr == '-');
    ptr += is_neg ? 1 : 0;
    while (*ptr >= '0' && *ptr <= '9') {
      value = value*10 + (*ptr++ - '0');
    }

    if (is_neg) {
      value = -value;
    }

    return true;
  } else {
    return false;
  }
}

bool Parse::Value(const char* stream, const char* match, uint32& value) {
  if (const char* found = CStringTraitsA::Strfind(stream, match)) {
    char* end;
    value = CStringTraitsA::Strtoi(found + CStringTraitsA::Strlen(match), &end, 10);
    return value != 0 || CharTraitsA::IsDigit(found[0]);
  }
  return false;
}

bool Parse::Value(const char* stream, const char* match, uint8& value) {
  //TODO Match의 길이를 선택적으로 가져올수 있다면 좋을듯? 아닌가... 흠...
  if (const char* found = CStringTraitsA::Strfind(stream, match)) {
    found += CStringTraitsA::Strlen(match);
    value = (uint8)CStringTraitsA::Atoi(found);
    return value != 0 || CharTraitsA::IsDigit(found[0]);
  }
  return false;
}

bool Parse::Value(const char* stream, const char* match, int8& value) {
  if (const char* found = CStringTraitsA::Strfind(stream, match)) {
    found += CStringTraitsA::Strlen(match);
    value = CStringTraitsA::Atoi(found);
    return value != 0 || CharTraitsA::IsDigit(found[0]);
  }
  return false;
}

bool Parse::Value(const char* stream, const char* match, uint16& value) {
  if (const char* found = CStringTraitsA::Strfind(stream, match)) {
    found += CStringTraitsA::Strlen(match);
    value = (uint16)CStringTraitsA::Atoi(found);
    return value != 0 || CharTraitsA::IsDigit(found[0]);
  }
  return false;
}

bool Parse::Value(const char* stream, const char* match, int16& value) {
  if (const char* found = CStringTraitsA::Strfind(stream, match)) {
    found += CStringTraitsA::Strlen(match);
    value = (int16)CStringTraitsA::Atoi(found);
    return value != 0 || CharTraitsA::IsDigit(found[0]);
  }
  return false;
}

bool Parse::Value(const char* stream, const char* match, float& value) {
  if (const char* found = CStringTraitsA::Strfind(stream, match)) {
    //TODO error handling
    value = CStringTraitsA::Atof(found + CStringTraitsA::Strlen(match));
    return true;
  }
  return false;
}

bool Parse::Value(const char* stream, const char* match, int32& value) {
  if (const char* found = CStringTraitsA::Strfind(stream, match)) {
    //TODO error handling
    value = CStringTraitsA::Atoi(found + CStringTraitsA::Strlen(match));
    return true;
  }
  return false;
}

bool Parse::Value(const char* stream, const char* match, bool& value) {
  char buf[16];
  if (Value(stream, match, buf, countof(buf))) {
    //TODO ToBool을 구태여 함수 형태로 있을 필요가 있나...??
    value = CStringTraitsA::ToBool(buf);
    return true;
  } else {
    return false;
  }
}

bool Parse::Value(const char* stream, const char* match, Uuid& value) {
  return Uuid::TryParse(stream, value);
}

/*
bool Parse::Value(const char* stream, const char* match, Name& value) {
  char buf[NAME_SIZE];
  if (!Value(stream, match, buf, countof(buf))) {
    return false;
  }
  value = Name(buf);
  return true;
}
*/

/*
bool Parse::Text(const char* buffer, Text& value, const char* ns) {
  TODO("implement this.");
  return false;
  //return CTextStringHelper::ReadFromString(buffer, value, ns);
}

bool Parse::Value(const char* stream, const char* match, Text& value, const char* ns) {
  stream = CStringTraitsA::Strfind(stream, match);
  if (stream) {
    stream += CStringTraitsA::Strlen(match);
    return Value(stream, value, ns);
  }
  return false;
}
*/

bool Parse::Command(const char** stream,
                    const char* match,
                    bool parse_might_trigger_execution) {
  //한번이라도 실행되면, 커맨드 관련 도움말을 빌드하는 구조인데...
  //소스 전체를 훑어서 처리하는게 좋지 않을런지? 복잡하려나...
//#if !FUN_BUILD_SHIPPING
//  if (g_console_command_library) {
//    g_console_command_library->OnParseCommand(match);
//
//    if (parse_might_trigger_execution) {
//      // Better we fail the test - we only wanted to find all commands.
//      return false;
//    }
//  }
//#endif //!FUN_BUILD_SHIPPING

  while (**stream == ' ' || **stream == 9) {
    ++(*stream);
  }

  if (CStringTraitsA::Strnicmp(*stream, match, CStringTraitsA::Strlen(match)) == 0) {
    *stream += CStringTraitsA::Strlen(match);

    if (!CharTraitsA::IsAlnum(**stream)) {
    //if (!CharTraitsA::IsAlnum(**stream) && (**stream != '_') && (**stream != '.')) { // more correct e.g. a cvar called "log.abc" should work but breaks some code so commented out
      while (**stream == ' ' || **stream == 9) {
        ++(*stream);
      }
      return true; // Success.
    } else {
      *stream -= CStringTraitsA::Strlen(match);
      return false; // Only found partial match.
    }
  } else {
    return false; // No match.
  }
}

void Parse::Next(const char** stream) {
  // Skip over spaces, tabs, cr's, and linefeeds.
SkipJunk:
  while (**stream == ' ' || **stream == 9 || **stream == 13 || **stream == 10) {
    ++*stream;
  }

  if (**stream == ';') {
    // Skip past comments.
    while (**stream != 0 && **stream != 10 && **stream != 13) {
      ++*stream;
    }
    goto SkipJunk;
  }

  // Upon exit, *stream either points to valid stream or a nul.
}

bool Parse::Token(const char*& str, char* result, int32 max_len, bool use_escape) {
  int32 len = 0;

  // Skip preceeding spaces and tabs.
  while (CharTraitsA::IsWhitespace(*str)) {
    ++str;
  }

  if (*str == '"') {
    // Get quoted string.
    ++str;
    while (*str && *str != '"' && (len + 1) < max_len) {
      char c = *str++;
      if (c == '\\' && use_escape) {
        // Get escape.
        c = *str++;
        if (c == 0) {
          break;
        }
      }

      if ((len + 1) < max_len) {
        result[len++] = c;
      }
    }

    if (*str == '"') {
      ++str;
    }
  } else {
    // Get unquoted string
    // (that might contain a quoted part, which will be left intact).
    // For example, -arg="foo bar baz", will be treated as one token,
    // with quotes intact
    bool in_quote = false;

    while (1) {
      char c = *str;
      if (c == 0 || (CharTraitsA::IsWhitespace(c) && !in_quote)) {
        break;
      }
      ++str;

      // Preserve escapes if they're in a quoted string
      // (the check for " is in the else to let \" work as expected)
      if (c == '\\' && use_escape && in_quote) {
        if ((len + 1) < max_len) {
          result[len++] = c;
        }

        c = *str;
        if (c == 0) {
          break;
        }
        ++str;
      } else if (c == '"') {
        in_quote = !in_quote;
      }

      if ((len + 1) < max_len) {
        result[len++] = c;
      }
    }
  }
  result[len] = 0;
  return len != 0;
}

bool Parse::Token(const char*& str, String& arg, bool use_escape) {
  arg.Clear();

  // Skip preceeding spaces and tabs.
  while (CharTraitsA::IsWhitespace(*str)) {
    ++str;
  }

  if (*str == '"') {
    // Get quoted string.
    ++str;
    while (*str && *str != '"') {
      char c = *str++;
      if (c == '\\' && use_escape) {
        // Get escape.
        c = *str++;
        if (c == 0) {
          break;
        }
      }

      arg += c;
    }

    if (*str == '"') {
      ++str;
    }
  } else {
    // Get unquoted string (that might contain a quoted part, which will be left intact).
    // For example, -ARG="foo bar baz", will be treated as one token, with quotes intact
    bool in_quote = false;

    while (1) {
      char c = *str;
      if (c == 0 || (CharTraitsA::IsWhitespace(c) && !in_quote)) {
        break;
      }
      ++str;

      // Preserve escapes if they're in a quoted string
      // (the check for " is in the else to let \" work as expected)
      if (c == '\\' && use_escape && in_quote) {
        arg += c;

        c = *str;
        if (c == 0) {
          break;
        }
        ++str;
      } else if (c == '"') {
        in_quote = !in_quote;
      }

      arg += c;
    }
  }

  return arg.Len() > 0;
}

String Parse::Token(const char*& str, bool use_escape) {
  //TODO token 길이가 매우 긴 경우에는 truncation이 발생할것인데..
  char buf[1024];
  if (Parse::Token(str, buf, countof(buf), use_escape)) {
    return String(buf);
  } else {
    return "";
  }
}

bool Parse::AlnumToken(const char*& str, String& arg) {
  arg.Clear();

  // Skip preceeding spaces and tabs.
  while (CharTraitsA::IsWhitespace(*str)) {
    ++str;
  }

  while (CharTraitsA::IsAlnum(*str) || *str == '_') {
    arg += *str;
    ++str;
  }

  return arg.Len() > 0;
}

bool Parse::Line(const char** stream, char* result, int32 max_len, bool exact) {
  bool got_stream = false;
  bool is_quoted = false;
  bool ignore = false;

  *result = 0;
  while (**stream != 0 && **stream != 10 && **stream != 13 && --max_len > 0) {
    // start of comments.
    if (!is_quoted && !exact && (*stream)[0] == '/' && (*stream)[1] == '/') {
      ignore = true;
    }

    // Command chaining.
    if (!is_quoted && !exact && **stream == '|') {
      break;
    }

    // Check quoting.
    is_quoted = is_quoted ^ (**stream == 34);
    got_stream = true;

    // Got stuff.
    if (!ignore) {
      *(result++) = *((*stream)++);
    } else {
      (*stream)++;
    }
  }

  if (exact) {
    // Eat up exactly one CR/LF.
    if (**stream == 13) {
      (*stream)++;
    }

    if (**stream == 10) {
      (*stream)++;
    }
  } else {
    // Eat up all CR/LF's.
    while (**stream == 10 || **stream == 13 || **stream == '|') {
      (*stream)++;
    }
  }
  *result = 0;
  return **stream != 0 || got_stream;
}

bool Parse::Line(const char** stream, String& result, bool exact) {
  bool got_stream = false;
  bool is_quoted = false;
  bool ignore = false;

  result = "";

  while (**stream != 0 && **stream != 10 && **stream != 13) {
    // start of comments.
    if (!is_quoted && !exact && (*stream)[0] == '/' && (*stream)[1] == '/') {
      ignore = true;
    }

    // Command chaining.
    if (!is_quoted && !exact && **stream == '|') {
      break;
    }

    // Check quoting.
    is_quoted = is_quoted ^ (**stream == 34);
    got_stream = true;

    // Got stuff.
    if (!ignore) {
      result.Append(*((*stream)++));
    } else {
      (*stream)++;
    }
  }

  if (exact) {
    // Eat up exactly one CR/LF.
    if (**stream == 13) {
      ++(*stream);
    }

    if (**stream == 10) {
      ++(*stream);
    }
  } else {
    // Eat up all CR/LF's.
    while (**stream == 10 || **stream == 13 || **stream == '|') {
      ++(*stream);
    }
  }

  return **stream != 0 || got_stream;
}

bool Parse::LineExtended( const char** stream,
                          String& result,
                          int32& consumed_line_count,
                          bool exact) {
  bool got_stream = false;
  bool is_quoted = false;
  bool ignore = false;
  int32 bracket_depth = 0;

  result = "";
  consumed_line_count = 0;

  while (**stream != 0 && ((**stream != 10 && **stream != 13) || bracket_depth > 0)) {
    // start of comments.
    if (!is_quoted && !exact && (*stream)[0] == '/' && (*stream)[1] == '/') {
      ignore = true;
    }

    // Command chaining.
    if (!is_quoted && !exact && **stream == '|') {
      break;
    }

    got_stream = true;

    // bracketed line break
    if (**stream == 10 || **stream == 13) {
      fun_check(bracket_depth > 0);

      result.Append(' ');
      ++consumed_line_count;
      ++(*stream);
      if (**stream == 10 || **stream == 13) {
        ++(*stream);
      }
    }
    // allow line break if the end of the line is a backslash
    else if (!is_quoted && (*stream)[0] == '\\' && ((*stream)[1] == 10 || (*stream)[1] == 13)) {
      result.Append(' ');
      ++consumed_line_count;
      (*stream) += 2;
      if (**stream == 10 || **stream == 13) {
        ++(*stream);
      }
    }
    // check for starting or ending brace
    else if (!is_quoted && **stream == '{') {
      bracket_depth++;
      (*stream)++;
    }
    else if (!is_quoted && **stream == '}' && bracket_depth > 0) {
      bracket_depth--;
      ++(*stream);
    }
    else {
      // Check quoting.
      is_quoted = is_quoted ^ (**stream == 34);

      // Got stuff.
      if (!ignore) {
        result.Append(*((*stream)++));
      }
      else {
        ++(*stream);
      }
    }
  }

  if (**stream == 0) {
    if (got_stream) {
      ++consumed_line_count;
    }
  }
  else if (exact) {
    // Eat up exactly one CR/LF.
    if (**stream == 13 || **stream == 10) {
      ++consumed_line_count;

      if (**stream == 13) {
        ++(*stream);
      }

      if (**stream == 10) {
        ++(*stream);
      }
    }
  }
  else {
    // Eat up all CR/LF's.
    while (**stream == 10 || **stream == 13 || **stream == '|') {
      if (**stream != '|') {
        ++consumed_line_count;
      }

      if (((*stream)[0] == 10 && (*stream)[1] == 13) || ((*stream)[0] == 13 && (*stream)[1] == 10)) {
        ++(*stream);
      }

      ++(*stream);
    }
  }

  return **stream != 0 || got_stream;
}

uint32 Parse::HexNumber(const char* hex_string) {
  uint32 rv = 0;
  while (*hex_string) {
    rv *= 16;
    rv += Parse::HexDigit(*hex_string++);
  }
  return rv;
}

bool Parse::SchemeNameFromUri(const char* uri, String& out_scheme_name) {
  for (int32 i = 0; ; ++i) {
    const char ch = uri[i];

    if (!CharTraitsA::IsAlpha(ch) &&
        !CharTraitsA::IsDigit(ch) &&
        ch != '+' &&
        ch != '.' &&
        ch != '-') {
      if (ch == ':' && i > 0) {
        out_scheme_name = String(uri, i);
        return true;
      }
      return false;
    }
  }
  return false;
}

} // namespace fun




//-----------------------------------------------------------------------------
// 아래 코드는 샘플 코드며 실제로는 빌드 안됨.
//-----------------------------------------------------------------------------

#if 0

//
// Vector2
//

inline String Vector2::ToString() const
{
  return String::Format("x={0} y={1}", x, y);
}

inline bool Vector2::ParseFromString(const String& string)
{
  x = y = 0.f;
  if (!Parse::Value(string.c_str(), "x=", &x)) return false;
  if (!Parse::Value(string.c_str(), "y=", &y)) return false;
  return true;
}


//
// Vector
//

inline String Vector::ToString() const
{
  return String::Format("x={0} y={1} z={2}", x, y, z);
}

inline bool Vector::ParseFromString(const String& string)
{
  x = y = z = 0.f;
  FUN_DO_CHECKED(Parse::Value(string.c_str(), "x=", &x));
  FUN_DO_CHECKED(Parse::Value(string.c_str(), "y=", &y));
  FUN_DO_CHECKED(Parse::Value(string.c_str(), "z=", &z));
  return true;
}


//
// Vector4
//

inline String Vector4::ToString() const
{
  return String::Format("x={0} y={1} z={2} w={3}", x, y, z, w);
}

inline bool Vector4::ParseFromString(const String& string)
{
  x = y = z = w = 0.f;
  if (!Parse::Value(string.c_str(), "x=", &x)) return false;
  if (!Parse::Value(string.c_str(), "y=", &y)) return false;
  if (!Parse::Value(string.c_str(), "z=", &z)) return false;
  if (!Parse::Value(string.c_str(), "w=", &w)) return false;
  return true;
}


//
// Rotator
//

inline String Rotator::ToString() const
{
  return String::Format("pitch={0} yaw={1} roll={2}", pitch, yaw, roll);
}

inline bool Rotator::ParseFromString(const String& string)
{
  pitch = yaw = roll = 0.f;
  if (!Parse::Value(string.c_str(), "pitch=", &pitch)) return false;
  if (!Parse::Value(string.c_str(), "yaw=", &yaw)) return false;
  if (!Parse::Value(string.c_str(), "roll=", &roll)) return false;
  DiagnosticCheckNaN();
  return true;
}

#endif
