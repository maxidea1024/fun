/**
 * Auto-generated by IDL Compiler (2.1.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#pragma once

#include "FUN.h"
#include "dump_types.h"

#define IDL_BEGIN_GLOBAL_NAMESPACE }
#define IDL_END_GLOBAL_NAMESPACE namespace fun {

namespace fun {

//==============================================================================
// Service DumpC2S
//==============================================================================

namespace DumpC2S
{
  struct CDumpC2S_Chunk_Args
  {
    // arguments.
    fun::ByteArray Chunk;

    // Construction
    inline CDumpC2S_Chunk_Args() {}

    // Reader
    bool Read(fun::IMessageIn& Input__)
    {
      #define DO_CHECKED__(Expr) { if (!(Expr)) return false; }
      DO_CHECKED__(fun::FlexFormat::ReadBytes(Input__, Chunk));
      return true;
      #undef DO_CHECKED__
    }

    // ToString(Json style for diagnostics)
    inline fun::String ToString() const
    {
      fun::String result = TEXT("{");
      result << TEXT("\"Chunk\":") << fun::ToString(Chunk);
      result << TEXT("}");
      return result;
    }
  };

  struct CDumpC2S_Chunk_PArgs
  {
    // arguments.
    const fun::ByteArray* Chunk;

    // Construction
    inline CDumpC2S_Chunk_PArgs(const fun::ByteArray* Chunk_)
      : Chunk(Chunk_)
    {}

    // Writer
    inline void Write(fun::IMessageOut& Output__)
    {
      fun::FlexFormat::WriteBytes(Output__, *Chunk);
    }

    // ToString(Json style for diagnostics)
    inline fun::String ToString() const
    {
      fun::String result = TEXT("{");
      result << TEXT("\"Chunk\":") << fun::ToString(*Chunk);
      result << TEXT("}");
      return result;
    }
  };
} // end of namespace DumpC2S


//==============================================================================
// Service DumpS2C
//==============================================================================

namespace DumpS2C
{
} // end of namespace DumpS2C


} // end of namespace fun

#undef IDL_BEGIN_GLOBAL_NAMESPACE
#undef IDL_END_GLOBAL_NAMESPACE
