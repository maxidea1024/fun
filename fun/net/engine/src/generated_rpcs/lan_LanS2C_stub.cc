/**
 * Auto-generated by IDL Compiler (2.1.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#include "lan_LanS2C_stub.h"
#include "lan.h" // _Args, _PArgs

namespace fun {
namespace LanS2C
{
  bool Stub::ProcessReceivedMessage(fun::ReceivedMessage& received_msg, void* host_tag)
  {
    #define DO_CHECKED__(Expr) { if (!(Expr)) goto Failure__; }

    const fun::HostId RemoteId__ = received_msg.remote_id;
    fun::IMessageIn& ImmutableMessage__ = received_msg.unsafe_message;
    const fun::int32 SavedReadPosition__ = ImmutableMessage__.GetPosition();

    fun::RpcHint RpcHint__;
    RpcHint__.relayed = received_msg.relayed;
    RpcHint__.host_tag = host_tag;

    fun::RpcId RpcId__;
    fun::RpcHeader RpcHeader__;
    DO_CHECKED__(fun::LiteFormat::Read(ImmutableMessage__, RpcId__));
    DO_CHECKED__(RpcHeader__.Read(ImmutableMessage__));

    RpcHint__.result_code = RpcHeader__.result_code;
    RpcHint__.error_message = RpcHeader__.error_message;

    switch ((fun::uint32)RpcId__)
    {
      case (fun::uint32)RpcIds::P2PGroup_MemberJoin:
      {
          // Declare arguments.
          fun::HostId group_id = fun::HostId_None;
          fun::HostId member_id = fun::HostId_None;
          fun::ByteArray custom_field;
          fun::uint32 event_id = 0;
          fun::ByteArray P2PAESSessionKey;
          fun::ByteArray P2PRC4SessionKey;
          fun::Uuid ConnectionTag = fun::Uuid::None;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, group_id));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, member_id));
            DO_CHECKED__(fun::FlexFormat::ReadBytes(ImmutableMessage__, custom_field));
            DO_CHECKED__(fun::FlexFormat::ReadUInt32(ImmutableMessage__, event_id));
            DO_CHECKED__(fun::FlexFormat::ReadBytes(ImmutableMessage__, P2PAESSessionKey));
            DO_CHECKED__(fun::FlexFormat::ReadBytes(ImmutableMessage__, P2PRC4SessionKey));
            DO_CHECKED__(fun::FlexFormat::ReadGuid(ImmutableMessage__, ConnectionTag));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::P2PGroup_MemberJoin, RpcNames::P2PGroup_MemberJoin());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"group_id\":") + fun::ToString(group_id);
            ArgsStr__ += TEXT(",\"member_id\":") + fun::ToString(member_id);
            ArgsStr__ += TEXT(",\"custom_field\":") + fun::ToString(custom_field);
            ArgsStr__ += TEXT(",\"event_id\":") + fun::ToString(event_id);
            ArgsStr__ += TEXT(",\"P2PAESSessionKey\":") + fun::ToString(P2PAESSessionKey);
            ArgsStr__ += TEXT(",\"P2PRC4SessionKey\":") + fun::ToString(P2PRC4SessionKey);
            ArgsStr__ += TEXT(",\"ConnectionTag\":") + fun::ToString(ConnectionTag);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::P2PGroup_MemberJoin, RpcNames::P2PGroup_MemberJoin(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::P2PGroup_MemberJoin, RpcNames::P2PGroup_MemberJoin(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnP2PGroup_MemberJoin)
          {
            bIsImplemented__ = OnP2PGroup_MemberJoin(RemoteId__, RpcHint__, group_id, member_id, custom_field, event_id, P2PAESSessionKey, P2PRC4SessionKey, ConnectionTag);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = P2PGroup_MemberJoin(RemoteId__, RpcHint__, group_id, member_id, custom_field, event_id, P2PAESSessionKey, P2PRC4SessionKey, ConnectionTag);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::P2PGroup_MemberJoin, RpcNames::P2PGroup_MemberJoin());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::P2PGroup_MemberJoin, RpcNames::P2PGroup_MemberJoin(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::P2PGroup_MemberJoin_Unencrypted:
      {
          // Declare arguments.
          fun::HostId group_id = fun::HostId_None;
          fun::HostId member_id = fun::HostId_None;
          fun::ByteArray custom_field;
          fun::uint32 event_id = 0;
          fun::Uuid ConnectionTag = fun::Uuid::None;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, group_id));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, member_id));
            DO_CHECKED__(fun::FlexFormat::ReadBytes(ImmutableMessage__, custom_field));
            DO_CHECKED__(fun::FlexFormat::ReadUInt32(ImmutableMessage__, event_id));
            DO_CHECKED__(fun::FlexFormat::ReadGuid(ImmutableMessage__, ConnectionTag));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::P2PGroup_MemberJoin_Unencrypted, RpcNames::P2PGroup_MemberJoin_Unencrypted());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"group_id\":") + fun::ToString(group_id);
            ArgsStr__ += TEXT(",\"member_id\":") + fun::ToString(member_id);
            ArgsStr__ += TEXT(",\"custom_field\":") + fun::ToString(custom_field);
            ArgsStr__ += TEXT(",\"event_id\":") + fun::ToString(event_id);
            ArgsStr__ += TEXT(",\"ConnectionTag\":") + fun::ToString(ConnectionTag);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::P2PGroup_MemberJoin_Unencrypted, RpcNames::P2PGroup_MemberJoin_Unencrypted(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::P2PGroup_MemberJoin_Unencrypted, RpcNames::P2PGroup_MemberJoin_Unencrypted(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnP2PGroup_MemberJoin_Unencrypted)
          {
            bIsImplemented__ = OnP2PGroup_MemberJoin_Unencrypted(RemoteId__, RpcHint__, group_id, member_id, custom_field, event_id, ConnectionTag);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = P2PGroup_MemberJoin_Unencrypted(RemoteId__, RpcHint__, group_id, member_id, custom_field, event_id, ConnectionTag);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::P2PGroup_MemberJoin_Unencrypted, RpcNames::P2PGroup_MemberJoin_Unencrypted());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::P2PGroup_MemberJoin_Unencrypted, RpcNames::P2PGroup_MemberJoin_Unencrypted(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::P2PGroup_MemberLeave:
      {
          // Declare arguments.
          fun::HostId member_id = fun::HostId_None;
          fun::HostId group_id = fun::HostId_None;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, member_id));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, group_id));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::P2PGroup_MemberLeave, RpcNames::P2PGroup_MemberLeave());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"member_id\":") + fun::ToString(member_id);
            ArgsStr__ += TEXT(",\"group_id\":") + fun::ToString(group_id);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::P2PGroup_MemberLeave, RpcNames::P2PGroup_MemberLeave(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::P2PGroup_MemberLeave, RpcNames::P2PGroup_MemberLeave(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnP2PGroup_MemberLeave)
          {
            bIsImplemented__ = OnP2PGroup_MemberLeave(RemoteId__, RpcHint__, member_id, group_id);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = P2PGroup_MemberLeave(RemoteId__, RpcHint__, member_id, group_id);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::P2PGroup_MemberLeave, RpcNames::P2PGroup_MemberLeave());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::P2PGroup_MemberLeave, RpcNames::P2PGroup_MemberLeave(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::ReliablePong:
      {
          // No arguments.

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::ReliablePong, RpcNames::ReliablePong());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->NotifyCallFromStub(RpcIds::ReliablePong, RpcNames::ReliablePong(), TEXT("{}"));
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::ReliablePong, RpcNames::ReliablePong(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnReliablePong)
          {
            bIsImplemented__ = OnReliablePong(RemoteId__, RpcHint__);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = ReliablePong(RemoteId__, RpcHint__);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::ReliablePong, RpcNames::ReliablePong());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::ReliablePong, RpcNames::ReliablePong(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::P2PConnectStart:
      {
          // Declare arguments.
          fun::HostId peer_id = fun::HostId_None;
          fun::InetAddress external_addr = fun::InetAddress();

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, peer_id));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, external_addr));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::P2PConnectStart, RpcNames::P2PConnectStart());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"peer_id\":") + fun::ToString(peer_id);
            ArgsStr__ += TEXT(",\"external_addr\":") + fun::ToString(external_addr);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::P2PConnectStart, RpcNames::P2PConnectStart(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::P2PConnectStart, RpcNames::P2PConnectStart(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnP2PConnectStart)
          {
            bIsImplemented__ = OnP2PConnectStart(RemoteId__, RpcHint__, peer_id, external_addr);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = P2PConnectStart(RemoteId__, RpcHint__, peer_id, external_addr);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::P2PConnectStart, RpcNames::P2PConnectStart());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::P2PConnectStart, RpcNames::P2PConnectStart(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::ShutdownTcpAck:
      {
          // No arguments.

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::ShutdownTcpAck, RpcNames::ShutdownTcpAck());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->NotifyCallFromStub(RpcIds::ShutdownTcpAck, RpcNames::ShutdownTcpAck(), TEXT("{}"));
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::ShutdownTcpAck, RpcNames::ShutdownTcpAck(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnShutdownTcpAck)
          {
            bIsImplemented__ = OnShutdownTcpAck(RemoteId__, RpcHint__);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = ShutdownTcpAck(RemoteId__, RpcHint__);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::ShutdownTcpAck, RpcNames::ShutdownTcpAck());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::ShutdownTcpAck, RpcNames::ShutdownTcpAck(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::RequestAutoPrune:
      {
          // No arguments.

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::RequestAutoPrune, RpcNames::RequestAutoPrune());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->NotifyCallFromStub(RpcIds::RequestAutoPrune, RpcNames::RequestAutoPrune(), TEXT("{}"));
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::RequestAutoPrune, RpcNames::RequestAutoPrune(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnRequestAutoPrune)
          {
            bIsImplemented__ = OnRequestAutoPrune(RemoteId__, RpcHint__);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = RequestAutoPrune(RemoteId__, RpcHint__);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::RequestAutoPrune, RpcNames::RequestAutoPrune());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::RequestAutoPrune, RpcNames::RequestAutoPrune(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::GroupP2PConnectionComplete:
      {
          // Declare arguments.
          fun::HostId group_id = fun::HostId_None;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, group_id));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::GroupP2PConnectionComplete, RpcNames::GroupP2PConnectionComplete());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"group_id\":") + fun::ToString(group_id);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::GroupP2PConnectionComplete, RpcNames::GroupP2PConnectionComplete(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::GroupP2PConnectionComplete, RpcNames::GroupP2PConnectionComplete(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnGroupP2PConnectionComplete)
          {
            bIsImplemented__ = OnGroupP2PConnectionComplete(RemoteId__, RpcHint__, group_id);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = GroupP2PConnectionComplete(RemoteId__, RpcHint__, group_id);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::GroupP2PConnectionComplete, RpcNames::GroupP2PConnectionComplete());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::GroupP2PConnectionComplete, RpcNames::GroupP2PConnectionComplete(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }
    }

    Failure__: ImmutableMessage__.SetPosition(SavedReadPosition__); return false;
    #undef DO_CHECKED__
  }
} // end of namespace LanS2C

} // end of namespace fun
