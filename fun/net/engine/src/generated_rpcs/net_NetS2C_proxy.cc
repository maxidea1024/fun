/**
 * Auto-generated by IDL Compiler (2.1.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#include "net_NetS2C_proxy.h"
#include "net.h" // _Args, _PArgs

namespace fun {
namespace NetS2C {

  bool Proxy::P2PGroup_MemberJoin(const fun::LinkId* rpc_sendto_list,
                                  const fun::int32 rpc_sendto_count,
                                  const fun::RpcCallOption& rpc_call_opt,
                                  const fun::LinkId& group_id,
                                  const fun::LinkId& member_id,
                                  const fun::ByteArray& custom_field,
                                  const fun::uint32 event_id,
                                  const fun::ByteArray& p2p_aes_session_key,
                                  const fun::ByteArray& p2p_rc4_session_key,
                                  const fun::FrameNumber& p2p_first_frame_number,
                                  const fun::Uuid& connection_tag,
                                  const bool direct_p2p_enabled,
                                  const fun::int32 bind_port) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::P2PGroup_MemberJoin);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // Write RPC function arguments.
    EngineTypes_UserTypeHandlers::Write(rpc_msg, group_id);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, member_id);
    fnff::WriteBytes(rpc_msg, custom_field);
    fnff::WriteUInt32(rpc_msg, event_id);
    fnff::WriteBytes(rpc_msg, p2p_aes_session_key);
    fnff::WriteBytes(rpc_msg, p2p_rc4_session_key);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, p2p_first_frame_number);
    fnff::WriteGuid(rpc_msg, connection_tag);
    fnff::WriteBool(rpc_msg, direct_p2p_enabled);
    fnff::WriteSInt32(rpc_msg, bind_port);

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      fun::String arg_str = TEXT("{");
      arg_str << TEXT("\"group_id\":") << fun::ToString(group_id);
      arg_str << TEXT(",\"member_id\":") << fun::ToString(member_id);
      arg_str << TEXT(",\"custom_field\":") << fun::ToString(custom_field);
      arg_str << TEXT(",\"event_id\":") << fun::ToString(event_id);
      arg_str << TEXT(",\"p2p_aes_session_key\":") << fun::ToString(p2p_aes_session_key);
      arg_str << TEXT(",\"p2p_rc4_session_key\":") << fun::ToString(p2p_rc4_session_key);
      arg_str << TEXT(",\"p2p_first_frame_number\":") << fun::ToString(p2p_first_frame_number);
      arg_str << TEXT(",\"connection_tag\":") << fun::ToString(connection_tag);
      arg_str << TEXT(",\"direct_p2p_enabled\":") << fun::ToString(direct_p2p_enabled);
      arg_str << TEXT(",\"bind_port\":") << fun::ToString(bind_port);
      arg_str << TEXT("}");

      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::P2PGroup_MemberJoin(),
                      RpcIds::P2PGroup_MemberJoin,
                      *arg_str);
    }
    else {
      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::P2PGroup_MemberJoin(),
                      RpcIds::P2PGroup_MemberJoin,
                      nullptr);
    }
  }

  bool Proxy::P2PGroup_MemberJoin_Unencrypted(
          const fun::LinkId* rpc_sendto_list,
          const fun::int32 rpc_sendto_count,
          const fun::RpcCallOption& rpc_call_opt,
          const fun::LinkId& group_id,
          const fun::LinkId& member_id,
          const fun::ByteArray& custom_field,
          const fun::uint32 event_id,
          const fun::FrameNumber& p2p_first_frame_number,
          const fun::Uuid& connection_tag,
          const bool direct_p2p_enabled,
          const fun::int32 bind_port) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::P2PGroup_MemberJoin_Unencrypted);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // Write RPC function arguments.
    EngineTypes_UserTypeHandlers::Write(rpc_msg, group_id);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, member_id);
    fnff::WriteBytes(rpc_msg, custom_field);
    fnff::WriteUInt32(rpc_msg, event_id);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, p2p_first_frame_number);
    fnff::WriteGuid(rpc_msg, connection_tag);
    fnff::WriteBool(rpc_msg, direct_p2p_enabled);
    fnff::WriteSInt32(rpc_msg, bind_port);

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      fun::String arg_str = TEXT("{");
      arg_str << TEXT("\"group_id\":") << fun::ToString(group_id);
      arg_str << TEXT(",\"member_id\":") << fun::ToString(member_id);
      arg_str << TEXT(",\"custom_field\":") << fun::ToString(custom_field);
      arg_str << TEXT(",\"event_id\":") << fun::ToString(event_id);
      arg_str << TEXT(",\"p2p_first_frame_number\":") << fun::ToString(p2p_first_frame_number);
      arg_str << TEXT(",\"connection_tag\":") << fun::ToString(connection_tag);
      arg_str << TEXT(",\"direct_p2p_enabled\":") << fun::ToString(direct_p2p_enabled);
      arg_str << TEXT(",\"bind_port\":") << fun::ToString(bind_port);
      arg_str << TEXT("}");

      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::P2PGroup_MemberJoin_Unencrypted(),
                      RpcIds::P2PGroup_MemberJoin_Unencrypted,
                      *arg_str);
    }
    else {
      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::P2PGroup_MemberJoin_Unencrypted(),
                      RpcIds::P2PGroup_MemberJoin_Unencrypted,
                      nullptr);
    }
  }

  bool Proxy::P2PRecycleComplete( const fun::LinkId* rpc_sendto_list,
                                  const fun::int32 rpc_sendto_count,
                                  const fun::RpcCallOption& rpc_call_opt,
                                  const fun::LinkId& peer_id,
                                  const bool is_recycled,
                                  const fun::InetAddress internal_addr,
                                  const fun::InetAddress external_addr,
                                  const fun::InetAddress send_addr,
                                  const fun::InetAddress recv_addr) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::P2PRecycleComplete);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // Write RPC function arguments.
    EngineTypes_UserTypeHandlers::Write(rpc_msg, peer_id);
    fnff::WriteBool(rpc_msg, is_recycled);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, internal_addr);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, external_addr);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, send_addr);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, recv_addr);

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      fun::String arg_str = TEXT("{");
      arg_str << TEXT("\"peer_id\":") << fun::ToString(peer_id);
      arg_str << TEXT(",\"is_recycled\":") << fun::ToString(is_recycled);
      arg_str << TEXT(",\"internal_addr\":") << fun::ToString(internal_addr);
      arg_str << TEXT(",\"external_addr\":") << fun::ToString(external_addr);
      arg_str << TEXT(",\"send_addr\":") << fun::ToString(send_addr);
      arg_str << TEXT(",\"recv_addr\":") << fun::ToString(recv_addr);
      arg_str << TEXT("}");

      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::P2PRecycleComplete(),
                      RpcIds::P2PRecycleComplete,
                      *arg_str);
    }
    else {
      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::P2PRecycleComplete(),
                      RpcIds::P2PRecycleComplete,
                      nullptr);
    }
  }

  bool Proxy::RequestP2PHolepunch(const fun::LinkId* rpc_sendto_list,
                                  const fun::int32 rpc_sendto_count,
                                  const fun::RpcCallOption& rpc_call_opt,
                                  const fun::LinkId& peer_id,
                                  const fun::InetAddress internal_addr,
                                  const fun::InetAddress external_addr) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::RequestP2PHolepunch);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // Write RPC function arguments.
    EngineTypes_UserTypeHandlers::Write(rpc_msg, peer_id);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, internal_addr);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, external_addr);

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      fun::String arg_str = TEXT("{");
      arg_str << TEXT("\"peer_id\":") << fun::ToString(peer_id);
      arg_str << TEXT(",\"internal_addr\":") << fun::ToString(internal_addr);
      arg_str << TEXT(",\"external_addr\":") << fun::ToString(external_addr);
      arg_str << TEXT("}");

      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::RequestP2PHolepunch(),
                      RpcIds::RequestP2PHolepunch,
                      *arg_str);
    }
    else {
      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::RequestP2PHolepunch(),
                      RpcIds::RequestP2PHolepunch,
                      nullptr);
    }
  }

  bool Proxy::P2P_NotifyDirectP2PDisconnected2(
        const fun::LinkId* rpc_sendto_list,
        const fun::int32 rpc_sendto_count,
        const fun::RpcCallOption& rpc_call_opt,
        const fun::LinkId& peer_id,
        const fun::ResultCode& reason) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::P2P_NotifyDirectP2PDisconnected2);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // Write RPC function arguments.
    EngineTypes_UserTypeHandlers::Write(rpc_msg, peer_id);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, reason);

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      fun::String arg_str = TEXT("{");
      arg_str << TEXT("\"peer_id\":") << fun::ToString(peer_id);
      arg_str << TEXT(",\"reason\":") << fun::ToString(reason);
      arg_str << TEXT("}");

      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::P2P_NotifyDirectP2PDisconnected2(),
                      RpcIds::P2P_NotifyDirectP2PDisconnected2,
                      *arg_str);
    }
    else {
      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::P2P_NotifyDirectP2PDisconnected2(),
                      RpcIds::P2P_NotifyDirectP2PDisconnected2,
                      nullptr);
    }
  }

  bool Proxy::P2PGroup_MemberLeave( const fun::LinkId* rpc_sendto_list,
                                    const fun::int32 rpc_sendto_count,
                                    const fun::RpcCallOption& rpc_call_opt,
                                    const fun::LinkId& member_id,
                                    const fun::LinkId& group_id) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::P2PGroup_MemberLeave);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // Write RPC function arguments.
    EngineTypes_UserTypeHandlers::Write(rpc_msg, member_id);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, group_id);

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      fun::String arg_str = TEXT("{");
      arg_str << TEXT("\"member_id\":") << fun::ToString(member_id);
      arg_str << TEXT(",\"group_id\":") << fun::ToString(group_id);
      arg_str << TEXT("}");

      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::P2PGroup_MemberLeave(),
                      RpcIds::P2PGroup_MemberLeave,
                      *arg_str);
    }
    else {
      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::P2PGroup_MemberLeave(),
                      RpcIds::P2PGroup_MemberLeave,
                      nullptr);
    }
  }

  bool Proxy::NotifyDirectP2PEstablish( const fun::LinkId* rpc_sendto_list,
                                        const fun::int32 rpc_sendto_count,
                                        const fun::RpcCallOption& rpc_call_opt,
                                        const fun::LinkId& A0,
                                        const fun::LinkId& B0,
                                        const fun::InetAddress X0,
                                        const fun::InetAddress Y0,
                                        const fun::InetAddress Z0,
                                        const fun::InetAddress W0) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::NotifyDirectP2PEstablish);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // Write RPC function arguments.
    EngineTypes_UserTypeHandlers::Write(rpc_msg, A0);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, B0);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, X0);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, Y0);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, Z0);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, W0);

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      fun::String arg_str = TEXT("{");
      arg_str << TEXT("\"A0\":") << fun::ToString(A0);
      arg_str << TEXT(",\"B0\":") << fun::ToString(B0);
      arg_str << TEXT(",\"X0\":") << fun::ToString(X0);
      arg_str << TEXT(",\"Y0\":") << fun::ToString(Y0);
      arg_str << TEXT(",\"Z0\":") << fun::ToString(Z0);
      arg_str << TEXT(",\"W0\":") << fun::ToString(W0);
      arg_str << TEXT("}");

      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::NotifyDirectP2PEstablish(),
                      RpcIds::NotifyDirectP2PEstablish,
                      *arg_str);
    }
    else {
      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::NotifyDirectP2PEstablish(),
                      RpcIds::NotifyDirectP2PEstablish,
                      nullptr);
    }
  }

  bool Proxy::ReliablePong( const fun::LinkId* rpc_sendto_list,
                            const fun::int32 rpc_sendto_count,
                            const fun::RpcCallOption& rpc_call_opt) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::ReliablePong);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // No RPC function arguments.

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::ReliablePong(),
                      RpcIds::ReliablePong,
                      TEXT("{}"));
    }
    else {
      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::ReliablePong(),
                      RpcIds::ReliablePong,
                      nullptr);
    }
  }

  bool Proxy::EnableIntraLogging( const fun::LinkId* rpc_sendto_list,
                                  const fun::int32 rpc_sendto_count,
                                  const fun::RpcCallOption& rpc_call_opt) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::EnableIntraLogging);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // No RPC function arguments.

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::EnableIntraLogging(), RpcIds::EnableIntraLogging, TEXT("{}"));
    }
    else {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::EnableIntraLogging(), RpcIds::EnableIntraLogging, nullptr);
    }
  }

  bool Proxy::DisableIntraLogging(const fun::LinkId* rpc_sendto_list,
                                  const fun::int32 rpc_sendto_count,
                                  const fun::RpcCallOption& rpc_call_opt) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::DisableIntraLogging);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // No RPC function arguments.

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::DisableIntraLogging(), RpcIds::DisableIntraLogging, TEXT("{}"));
    }
    else {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::DisableIntraLogging(), RpcIds::DisableIntraLogging, nullptr);
    }
  }

  bool Proxy::NotifyUdpToTcpFallbackByServer(
        const fun::LinkId* rpc_sendto_list,
        const fun::int32 rpc_sendto_count,
        const fun::RpcCallOption& rpc_call_opt) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::NotifyUdpToTcpFallbackByServer);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // No RPC function arguments.

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::NotifyUdpToTcpFallbackByServer(), RpcIds::NotifyUdpToTcpFallbackByServer, TEXT("{}"));
    }
    else {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::NotifyUdpToTcpFallbackByServer(), RpcIds::NotifyUdpToTcpFallbackByServer, nullptr);
    }
  }

  bool Proxy::NotifySpeedHackDetectorEnabled(
        const fun::LinkId* rpc_sendto_list,
        const fun::int32 rpc_sendto_count,
        const fun::RpcCallOption& rpc_call_opt,
        const bool enabled) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::NotifySpeedHackDetectorEnabled);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // Write RPC function arguments.
    fnff::WriteBool(rpc_msg, enabled);

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      fun::String arg_str = TEXT("{");
      arg_str << TEXT("\"enabled\":") << fun::ToString(enabled);
      arg_str << TEXT("}");

      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::NotifySpeedHackDetectorEnabled(), RpcIds::NotifySpeedHackDetectorEnabled, *arg_str);
    } else {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::NotifySpeedHackDetectorEnabled(), RpcIds::NotifySpeedHackDetectorEnabled, nullptr);
    }
  }

  bool Proxy::ShutdownTcpAck( const fun::LinkId* rpc_sendto_list,
                              const fun::int32 rpc_sendto_count,
                              const fun::RpcCallOption& rpc_call_opt) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::ShutdownTcpAck);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // No RPC function arguments.

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::ShutdownTcpAck(), RpcIds::ShutdownTcpAck, TEXT("{}"));
    } else {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::ShutdownTcpAck(), RpcIds::ShutdownTcpAck, nullptr);
    }
  }

  bool Proxy::RequestAutoPrune( const fun::LinkId* rpc_sendto_list,
                                const fun::int32 rpc_sendto_count,
                                const fun::RpcCallOption& rpc_call_opt) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::RequestAutoPrune);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // No RPC function arguments.

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::RequestAutoPrune(), RpcIds::RequestAutoPrune, TEXT("{}"));
    } else {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::RequestAutoPrune(), RpcIds::RequestAutoPrune, nullptr);
    }
  }

  bool Proxy::RenewP2PConnectionState(const fun::LinkId* rpc_sendto_list,
                                      const fun::int32 rpc_sendto_count,
                                      const fun::RpcCallOption& rpc_call_opt,
                                      const fun::LinkId& peer_id) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::RenewP2PConnectionState);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // Write RPC function arguments.
    EngineTypes_UserTypeHandlers::Write(rpc_msg, peer_id);

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      fun::String arg_str = TEXT("{");
      arg_str << TEXT("\"peer_id\":") << fun::ToString(peer_id);
      arg_str << TEXT("}");

      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::RenewP2PConnectionState(),
                      RpcIds::RenewP2PConnectionState,
                      *arg_str);
    }
    else {
      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::RenewP2PConnectionState(),
                      RpcIds::RenewP2PConnectionState,
                      nullptr);
    }
  }

  bool Proxy::NewDirectP2PConnection(const fun::LinkId* rpc_sendto_list, const fun::int32 rpc_sendto_count, const fun::RpcCallOption& rpc_call_opt, const fun::LinkId& peer_id)
  {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::NewDirectP2PConnection);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // Write RPC function arguments.
    EngineTypes_UserTypeHandlers::Write(rpc_msg, peer_id);

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      fun::String arg_str = TEXT("{");
      arg_str << TEXT("\"peer_id\":") << fun::ToString(peer_id);
      arg_str << TEXT("}");

      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::NewDirectP2PConnection(), RpcIds::NewDirectP2PConnection, *arg_str);
    }
    else {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::NewDirectP2PConnection(), RpcIds::NewDirectP2PConnection, nullptr);
    }
  }

  bool Proxy::RequestMeasureSendSpeed(const fun::LinkId* rpc_sendto_list, const fun::int32 rpc_sendto_count, const fun::RpcCallOption& rpc_call_opt, const bool enabled)
  {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::RequestMeasureSendSpeed);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // Write RPC function arguments.
    fnff::WriteBool(rpc_msg, enabled);

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      fun::String arg_str = TEXT("{");
      arg_str << TEXT("\"enabled\":") << fun::ToString(enabled);
      arg_str << TEXT("}");

      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::RequestMeasureSendSpeed(), RpcIds::RequestMeasureSendSpeed, *arg_str);
    }
    else {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::RequestMeasureSendSpeed(), RpcIds::RequestMeasureSendSpeed, nullptr);
    }
  }

  bool Proxy::S2C_RequestCreateUdpSocket( const fun::LinkId* rpc_sendto_list,
                                          const fun::int32 rpc_sendto_count,
                                          const fun::RpcCallOption& rpc_call_opt,
                                          const fun::NamedInetAddress& server_udp_addr) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::S2C_RequestCreateUdpSocket);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // Write RPC function arguments.
    EngineTypes_UserTypeHandlers::Write(rpc_msg, server_udp_addr);

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      fun::String arg_str = TEXT("{");
      arg_str << TEXT("\"server_udp_addr\":") << fun::ToString(server_udp_addr);
      arg_str << TEXT("}");

      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::S2C_RequestCreateUdpSocket(), RpcIds::S2C_RequestCreateUdpSocket, *arg_str);
    }
    else {
      return RpcCall(rpc_sendto_list, rpc_sendto_count, rpc_call_opt, rpc_msg, RpcNames::S2C_RequestCreateUdpSocket(), RpcIds::S2C_RequestCreateUdpSocket, nullptr);
    }
  }

  bool Proxy::S2C_CreateUdpSocketAck( const fun::LinkId* rpc_sendto_list,
                                      const fun::int32 rpc_sendto_count,
                                      const fun::RpcCallOption& rpc_call_opt,
                                      const bool ok,
                                      const fun::NamedInetAddress& server_udp_addr) {
    fun::MessageOut rpc_msg;

    // Write RPC function id.
    fun::LiteFormat::Write(rpc_msg, RpcIds::S2C_CreateUdpSocketAck);

    // Write RPC header.
    fun::RpcHeader::WriteOk(rpc_msg);

    // Write RPC function arguments.
    fnff::WriteBool(rpc_msg, ok);
    EngineTypes_UserTypeHandlers::Write(rpc_msg, server_udp_addr);

    if (notify_send_by_proxy_enabled_ && !engine_specific_only_) {
      fun::String arg_str = TEXT("{");
      arg_str << TEXT("\"ok\":") << fun::ToString(ok);
      arg_str << TEXT(",\"server_udp_addr\":") << fun::ToString(server_udp_addr);
      arg_str << TEXT("}");

      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::S2C_CreateUdpSocketAck(),
                      RpcIds::S2C_CreateUdpSocketAck,
                      *arg_str);
    }
    else {
      return RpcCall( rpc_sendto_list,
                      rpc_sendto_count,
                      rpc_call_opt,
                      rpc_msg,
                      RpcNames::S2C_CreateUdpSocketAck(),
                      RpcIds::S2C_CreateUdpSocketAck,
                      nullptr);
    }
  }

} // end of namespace NetS2C

} // end of namespace fun
