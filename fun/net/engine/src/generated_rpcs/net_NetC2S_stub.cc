/**
 * Auto-generated by IDL Compiler (2.1.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#include "net_NetC2S_stub.h"
#include "net.h" // _Args, _PArgs

namespace fun {
namespace NetC2S
{
  bool Stub::ProcessReceivedMessage(fun::ReceivedMessage& received_msg, void* host_tag)
  {
    #define DO_CHECKED__(Expr) { if (!(Expr)) goto Failure__; }

    const fun::HostId RemoteId__ = received_msg.remote_id;
    fun::IMessageIn& ImmutableMessage__ = received_msg.unsafe_message;
    const fun::int32 SavedReadPosition__ = ImmutableMessage__.GetPosition();

    fun::RpcHint RpcHint__;
    RpcHint__.relayed = received_msg.relayed;
    RpcHint__.host_tag = host_tag;

    fun::RpcId RpcId__;
    fun::RpcHeader RpcHeader__;
    DO_CHECKED__(fun::LiteFormat::Read(ImmutableMessage__, RpcId__));
    DO_CHECKED__(RpcHeader__.Read(ImmutableMessage__));

    RpcHint__.result_code = RpcHeader__.result_code;
    RpcHint__.error_message = RpcHeader__.error_message;

    switch ((fun::uint32)RpcId__)
    {
      case (fun::uint32)RpcIds::ReliablePing:
      {
          // Declare arguments.
          double recent_frame_rate = 0.0;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(fun::FlexFormat::ReadDouble(ImmutableMessage__, recent_frame_rate));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::ReliablePing, RpcNames::ReliablePing());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"recent_frame_rate\":") + fun::ToString(recent_frame_rate);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::ReliablePing, RpcNames::ReliablePing(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::ReliablePing, RpcNames::ReliablePing(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnReliablePing)
          {
            bIsImplemented__ = OnReliablePing(RemoteId__, RpcHint__, recent_frame_rate);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = ReliablePing(RemoteId__, RpcHint__, recent_frame_rate);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::ReliablePing, RpcNames::ReliablePing());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::ReliablePing, RpcNames::ReliablePing(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::P2P_NotifyDirectP2PDisconnected:
      {
          // Declare arguments.
          fun::HostId peer_id = fun::HostId_None;
          fun::ResultCode reason = (fun::ResultCode)0;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, peer_id));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, reason));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::P2P_NotifyDirectP2PDisconnected, RpcNames::P2P_NotifyDirectP2PDisconnected());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"peer_id\":") + fun::ToString(peer_id);
            ArgsStr__ += TEXT(",\"reason\":") + fun::ToString(reason);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::P2P_NotifyDirectP2PDisconnected, RpcNames::P2P_NotifyDirectP2PDisconnected(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::P2P_NotifyDirectP2PDisconnected, RpcNames::P2P_NotifyDirectP2PDisconnected(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnP2P_NotifyDirectP2PDisconnected)
          {
            bIsImplemented__ = OnP2P_NotifyDirectP2PDisconnected(RemoteId__, RpcHint__, peer_id, reason);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = P2P_NotifyDirectP2PDisconnected(RemoteId__, RpcHint__, peer_id, reason);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::P2P_NotifyDirectP2PDisconnected, RpcNames::P2P_NotifyDirectP2PDisconnected());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::P2P_NotifyDirectP2PDisconnected, RpcNames::P2P_NotifyDirectP2PDisconnected(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::NotifyUdpToTcpFallbackByClient:
      {
          // No arguments.

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::NotifyUdpToTcpFallbackByClient, RpcNames::NotifyUdpToTcpFallbackByClient());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->NotifyCallFromStub(RpcIds::NotifyUdpToTcpFallbackByClient, RpcNames::NotifyUdpToTcpFallbackByClient(), TEXT("{}"));
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::NotifyUdpToTcpFallbackByClient, RpcNames::NotifyUdpToTcpFallbackByClient(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnNotifyUdpToTcpFallbackByClient)
          {
            bIsImplemented__ = OnNotifyUdpToTcpFallbackByClient(RemoteId__, RpcHint__);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = NotifyUdpToTcpFallbackByClient(RemoteId__, RpcHint__);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::NotifyUdpToTcpFallbackByClient, RpcNames::NotifyUdpToTcpFallbackByClient());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::NotifyUdpToTcpFallbackByClient, RpcNames::NotifyUdpToTcpFallbackByClient(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::P2PGroup_MemberJoin_Ack:
      {
          // Declare arguments.
          fun::HostId group_id = fun::HostId_None;
          fun::HostId added_member_id = fun::HostId_None;
          fun::uint32 event_id = 0;
          bool bLocalPortReuseOk = false;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, group_id));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, added_member_id));
            DO_CHECKED__(fun::FlexFormat::ReadUInt32(ImmutableMessage__, event_id));
            DO_CHECKED__(fun::FlexFormat::ReadBool(ImmutableMessage__, bLocalPortReuseOk));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::P2PGroup_MemberJoin_Ack, RpcNames::P2PGroup_MemberJoin_Ack());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"group_id\":") + fun::ToString(group_id);
            ArgsStr__ += TEXT(",\"added_member_id\":") + fun::ToString(added_member_id);
            ArgsStr__ += TEXT(",\"event_id\":") + fun::ToString(event_id);
            ArgsStr__ += TEXT(",\"bLocalPortReuseOk\":") + fun::ToString(bLocalPortReuseOk);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::P2PGroup_MemberJoin_Ack, RpcNames::P2PGroup_MemberJoin_Ack(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::P2PGroup_MemberJoin_Ack, RpcNames::P2PGroup_MemberJoin_Ack(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnP2PGroup_MemberJoin_Ack)
          {
            bIsImplemented__ = OnP2PGroup_MemberJoin_Ack(RemoteId__, RpcHint__, group_id, added_member_id, event_id, bLocalPortReuseOk);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = P2PGroup_MemberJoin_Ack(RemoteId__, RpcHint__, group_id, added_member_id, event_id, bLocalPortReuseOk);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::P2PGroup_MemberJoin_Ack, RpcNames::P2PGroup_MemberJoin_Ack());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::P2PGroup_MemberJoin_Ack, RpcNames::P2PGroup_MemberJoin_Ack(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::NotifyP2PHolepunchSuccess:
      {
          // Declare arguments.
          fun::HostId A = fun::HostId_None;
          fun::HostId B = fun::HostId_None;
          fun::InetAddress a2b_send_addr = fun::InetAddress();
          fun::InetAddress a2b_recv_addr = fun::InetAddress();
          fun::InetAddress b2a_send_addr = fun::InetAddress();
          fun::InetAddress b2a_recv_addr = fun::InetAddress();

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, A));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, B));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, a2b_send_addr));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, a2b_recv_addr));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, b2a_send_addr));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, b2a_recv_addr));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::NotifyP2PHolepunchSuccess, RpcNames::NotifyP2PHolepunchSuccess());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"A\":") + fun::ToString(A);
            ArgsStr__ += TEXT(",\"B\":") + fun::ToString(B);
            ArgsStr__ += TEXT(",\"a2b_send_addr\":") + fun::ToString(a2b_send_addr);
            ArgsStr__ += TEXT(",\"a2b_recv_addr\":") + fun::ToString(a2b_recv_addr);
            ArgsStr__ += TEXT(",\"b2a_send_addr\":") + fun::ToString(b2a_send_addr);
            ArgsStr__ += TEXT(",\"b2a_recv_addr\":") + fun::ToString(b2a_recv_addr);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::NotifyP2PHolepunchSuccess, RpcNames::NotifyP2PHolepunchSuccess(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::NotifyP2PHolepunchSuccess, RpcNames::NotifyP2PHolepunchSuccess(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnNotifyP2PHolepunchSuccess)
          {
            bIsImplemented__ = OnNotifyP2PHolepunchSuccess(RemoteId__, RpcHint__, A, B, a2b_send_addr, a2b_recv_addr, b2a_send_addr, b2a_recv_addr);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = NotifyP2PHolepunchSuccess(RemoteId__, RpcHint__, A, B, a2b_send_addr, a2b_recv_addr, b2a_send_addr, b2a_recv_addr);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::NotifyP2PHolepunchSuccess, RpcNames::NotifyP2PHolepunchSuccess());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::NotifyP2PHolepunchSuccess, RpcNames::NotifyP2PHolepunchSuccess(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::ShutdownTcp:
      {
          // Declare arguments.
          fun::ByteArray comment;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(fun::FlexFormat::ReadBytes(ImmutableMessage__, comment));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::ShutdownTcp, RpcNames::ShutdownTcp());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"comment\":") + fun::ToString(comment);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::ShutdownTcp, RpcNames::ShutdownTcp(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::ShutdownTcp, RpcNames::ShutdownTcp(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnShutdownTcp)
          {
            bIsImplemented__ = OnShutdownTcp(RemoteId__, RpcHint__, comment);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = ShutdownTcp(RemoteId__, RpcHint__, comment);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::ShutdownTcp, RpcNames::ShutdownTcp());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::ShutdownTcp, RpcNames::ShutdownTcp(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::ShutdownTcpHandshake:
      {
          // No arguments.

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::ShutdownTcpHandshake, RpcNames::ShutdownTcpHandshake());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->NotifyCallFromStub(RpcIds::ShutdownTcpHandshake, RpcNames::ShutdownTcpHandshake(), TEXT("{}"));
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::ShutdownTcpHandshake, RpcNames::ShutdownTcpHandshake(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnShutdownTcpHandshake)
          {
            bIsImplemented__ = OnShutdownTcpHandshake(RemoteId__, RpcHint__);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = ShutdownTcpHandshake(RemoteId__, RpcHint__);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::ShutdownTcpHandshake, RpcNames::ShutdownTcpHandshake());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::ShutdownTcpHandshake, RpcNames::ShutdownTcpHandshake(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::NotifyLog:
      {
          // Declare arguments.
          fun::LogCategory Category = (fun::LogCategory)0;
          fun::String text;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, Category));
            DO_CHECKED__(fun::FlexFormat::ReadString(ImmutableMessage__, text));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::NotifyLog, RpcNames::NotifyLog());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"Category\":") + fun::ToString(Category);
            ArgsStr__ += TEXT(",\"text\":") + fun::ToString(text);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::NotifyLog, RpcNames::NotifyLog(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::NotifyLog, RpcNames::NotifyLog(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnNotifyLog)
          {
            bIsImplemented__ = OnNotifyLog(RemoteId__, RpcHint__, Category, text);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = NotifyLog(RemoteId__, RpcHint__, Category, text);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::NotifyLog, RpcNames::NotifyLog());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::NotifyLog, RpcNames::NotifyLog(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::NotifyLogHolepunchFreqFail:
      {
          // Declare arguments.
          fun::int32 Rank = 0;
          fun::String text;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(fun::FlexFormat::ReadSInt32(ImmutableMessage__, Rank));
            DO_CHECKED__(fun::FlexFormat::ReadString(ImmutableMessage__, text));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::NotifyLogHolepunchFreqFail, RpcNames::NotifyLogHolepunchFreqFail());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"Rank\":") + fun::ToString(Rank);
            ArgsStr__ += TEXT(",\"text\":") + fun::ToString(text);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::NotifyLogHolepunchFreqFail, RpcNames::NotifyLogHolepunchFreqFail(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::NotifyLogHolepunchFreqFail, RpcNames::NotifyLogHolepunchFreqFail(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnNotifyLogHolepunchFreqFail)
          {
            bIsImplemented__ = OnNotifyLogHolepunchFreqFail(RemoteId__, RpcHint__, Rank, text);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = NotifyLogHolepunchFreqFail(RemoteId__, RpcHint__, Rank, text);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::NotifyLogHolepunchFreqFail, RpcNames::NotifyLogHolepunchFreqFail());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::NotifyLogHolepunchFreqFail, RpcNames::NotifyLogHolepunchFreqFail(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::NotifyNatDeviceName:
      {
          // Declare arguments.
          fun::String DeviceName;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(fun::FlexFormat::ReadString(ImmutableMessage__, DeviceName));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::NotifyNatDeviceName, RpcNames::NotifyNatDeviceName());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"DeviceName\":") + fun::ToString(DeviceName);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::NotifyNatDeviceName, RpcNames::NotifyNatDeviceName(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::NotifyNatDeviceName, RpcNames::NotifyNatDeviceName(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnNotifyNatDeviceName)
          {
            bIsImplemented__ = OnNotifyNatDeviceName(RemoteId__, RpcHint__, DeviceName);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = NotifyNatDeviceName(RemoteId__, RpcHint__, DeviceName);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::NotifyNatDeviceName, RpcNames::NotifyNatDeviceName());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::NotifyNatDeviceName, RpcNames::NotifyNatDeviceName(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::NotifyPeerUdpSocketRestored:
      {
          // Declare arguments.
          fun::HostId PeerBID = fun::HostId_None;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, PeerBID));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::NotifyPeerUdpSocketRestored, RpcNames::NotifyPeerUdpSocketRestored());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"PeerBID\":") + fun::ToString(PeerBID);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::NotifyPeerUdpSocketRestored, RpcNames::NotifyPeerUdpSocketRestored(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::NotifyPeerUdpSocketRestored, RpcNames::NotifyPeerUdpSocketRestored(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnNotifyPeerUdpSocketRestored)
          {
            bIsImplemented__ = OnNotifyPeerUdpSocketRestored(RemoteId__, RpcHint__, PeerBID);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = NotifyPeerUdpSocketRestored(RemoteId__, RpcHint__, PeerBID);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::NotifyPeerUdpSocketRestored, RpcNames::NotifyPeerUdpSocketRestored());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::NotifyPeerUdpSocketRestored, RpcNames::NotifyPeerUdpSocketRestored(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::NotifyJitDirectP2PTriggered:
      {
          // Declare arguments.
          fun::HostId PeerBID = fun::HostId_None;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, PeerBID));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::NotifyJitDirectP2PTriggered, RpcNames::NotifyJitDirectP2PTriggered());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"PeerBID\":") + fun::ToString(PeerBID);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::NotifyJitDirectP2PTriggered, RpcNames::NotifyJitDirectP2PTriggered(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::NotifyJitDirectP2PTriggered, RpcNames::NotifyJitDirectP2PTriggered(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnNotifyJitDirectP2PTriggered)
          {
            bIsImplemented__ = OnNotifyJitDirectP2PTriggered(RemoteId__, RpcHint__, PeerBID);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = NotifyJitDirectP2PTriggered(RemoteId__, RpcHint__, PeerBID);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::NotifyJitDirectP2PTriggered, RpcNames::NotifyJitDirectP2PTriggered());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::NotifyJitDirectP2PTriggered, RpcNames::NotifyJitDirectP2PTriggered(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::NotifyNatDeviceNameDetected:
      {
          // Declare arguments.
          fun::String DeviceName;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(fun::FlexFormat::ReadString(ImmutableMessage__, DeviceName));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::NotifyNatDeviceNameDetected, RpcNames::NotifyNatDeviceNameDetected());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"DeviceName\":") + fun::ToString(DeviceName);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::NotifyNatDeviceNameDetected, RpcNames::NotifyNatDeviceNameDetected(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::NotifyNatDeviceNameDetected, RpcNames::NotifyNatDeviceNameDetected(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnNotifyNatDeviceNameDetected)
          {
            bIsImplemented__ = OnNotifyNatDeviceNameDetected(RemoteId__, RpcHint__, DeviceName);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = NotifyNatDeviceNameDetected(RemoteId__, RpcHint__, DeviceName);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::NotifyNatDeviceNameDetected, RpcNames::NotifyNatDeviceNameDetected());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::NotifyNatDeviceNameDetected, RpcNames::NotifyNatDeviceNameDetected(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::NotifySendSpeed:
      {
          // Declare arguments.
          double Speed = 0.0;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(fun::FlexFormat::ReadDouble(ImmutableMessage__, Speed));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::NotifySendSpeed, RpcNames::NotifySendSpeed());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"Speed\":") + fun::ToString(Speed);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::NotifySendSpeed, RpcNames::NotifySendSpeed(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::NotifySendSpeed, RpcNames::NotifySendSpeed(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnNotifySendSpeed)
          {
            bIsImplemented__ = OnNotifySendSpeed(RemoteId__, RpcHint__, Speed);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = NotifySendSpeed(RemoteId__, RpcHint__, Speed);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::NotifySendSpeed, RpcNames::NotifySendSpeed());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::NotifySendSpeed, RpcNames::NotifySendSpeed(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::ReportP2PPeerPing:
      {
          // Declare arguments.
          fun::HostId peer_id = fun::HostId_None;
          fun::uint32 recent_ping = 0;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, peer_id));
            DO_CHECKED__(fun::FlexFormat::ReadUInt32(ImmutableMessage__, recent_ping));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::ReportP2PPeerPing, RpcNames::ReportP2PPeerPing());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"peer_id\":") + fun::ToString(peer_id);
            ArgsStr__ += TEXT(",\"recent_ping\":") + fun::ToString(recent_ping);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::ReportP2PPeerPing, RpcNames::ReportP2PPeerPing(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::ReportP2PPeerPing, RpcNames::ReportP2PPeerPing(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnReportP2PPeerPing)
          {
            bIsImplemented__ = OnReportP2PPeerPing(RemoteId__, RpcHint__, peer_id, recent_ping);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = ReportP2PPeerPing(RemoteId__, RpcHint__, peer_id, recent_ping);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::ReportP2PPeerPing, RpcNames::ReportP2PPeerPing());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::ReportP2PPeerPing, RpcNames::ReportP2PPeerPing(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::C2S_RequestCreateUdpSocket:
      {
          // No arguments.

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::C2S_RequestCreateUdpSocket, RpcNames::C2S_RequestCreateUdpSocket());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->NotifyCallFromStub(RpcIds::C2S_RequestCreateUdpSocket, RpcNames::C2S_RequestCreateUdpSocket(), TEXT("{}"));
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::C2S_RequestCreateUdpSocket, RpcNames::C2S_RequestCreateUdpSocket(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnC2S_RequestCreateUdpSocket)
          {
            bIsImplemented__ = OnC2S_RequestCreateUdpSocket(RemoteId__, RpcHint__);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = C2S_RequestCreateUdpSocket(RemoteId__, RpcHint__);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::C2S_RequestCreateUdpSocket, RpcNames::C2S_RequestCreateUdpSocket());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::C2S_RequestCreateUdpSocket, RpcNames::C2S_RequestCreateUdpSocket(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::C2S_CreateUdpSocketAck:
      {
          // Declare arguments.
          bool bOk = false;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(fun::FlexFormat::ReadBool(ImmutableMessage__, bOk));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::C2S_CreateUdpSocketAck, RpcNames::C2S_CreateUdpSocketAck());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"bOk\":") + fun::ToString(bOk);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::C2S_CreateUdpSocketAck, RpcNames::C2S_CreateUdpSocketAck(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::C2S_CreateUdpSocketAck, RpcNames::C2S_CreateUdpSocketAck(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnC2S_CreateUdpSocketAck)
          {
            bIsImplemented__ = OnC2S_CreateUdpSocketAck(RemoteId__, RpcHint__, bOk);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = C2S_CreateUdpSocketAck(RemoteId__, RpcHint__, bOk);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::C2S_CreateUdpSocketAck, RpcNames::C2S_CreateUdpSocketAck());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::C2S_CreateUdpSocketAck, RpcNames::C2S_CreateUdpSocketAck(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::ReportC2CUdpMessageCount:
      {
          // Declare arguments.
          fun::HostId peer_id = fun::HostId_None;
          fun::uint32 udp_message_attempt_count = 0;
          fun::uint32 udp_message_success_count = 0;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, peer_id));
            DO_CHECKED__(fun::FlexFormat::ReadUInt32(ImmutableMessage__, udp_message_attempt_count));
            DO_CHECKED__(fun::FlexFormat::ReadUInt32(ImmutableMessage__, udp_message_success_count));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::ReportC2CUdpMessageCount, RpcNames::ReportC2CUdpMessageCount());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"peer_id\":") + fun::ToString(peer_id);
            ArgsStr__ += TEXT(",\"udp_message_attempt_count\":") + fun::ToString(udp_message_attempt_count);
            ArgsStr__ += TEXT(",\"udp_message_success_count\":") + fun::ToString(udp_message_success_count);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::ReportC2CUdpMessageCount, RpcNames::ReportC2CUdpMessageCount(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::ReportC2CUdpMessageCount, RpcNames::ReportC2CUdpMessageCount(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnReportC2CUdpMessageCount)
          {
            bIsImplemented__ = OnReportC2CUdpMessageCount(RemoteId__, RpcHint__, peer_id, udp_message_attempt_count, udp_message_success_count);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = ReportC2CUdpMessageCount(RemoteId__, RpcHint__, peer_id, udp_message_attempt_count, udp_message_success_count);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::ReportC2CUdpMessageCount, RpcNames::ReportC2CUdpMessageCount());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::ReportC2CUdpMessageCount, RpcNames::ReportC2CUdpMessageCount(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::ReportC2SUdpMessageTrialCount:
      {
          // Declare arguments.
          fun::uint32 to_server_udp_attempt_count = 0;

          // Read arguments.
          if (RpcHint__.result_code == 0)
          {
            DO_CHECKED__(fun::FlexFormat::ReadUInt32(ImmutableMessage__, to_server_udp_attempt_count));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::ReportC2SUdpMessageTrialCount, RpcNames::ReportC2SUdpMessageTrialCount());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"to_server_udp_attempt_count\":") + fun::ToString(to_server_udp_attempt_count);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::ReportC2SUdpMessageTrialCount, RpcNames::ReportC2SUdpMessageTrialCount(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::ReportC2SUdpMessageTrialCount, RpcNames::ReportC2SUdpMessageTrialCount(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnReportC2SUdpMessageTrialCount)
          {
            bIsImplemented__ = OnReportC2SUdpMessageTrialCount(RemoteId__, RpcHint__, to_server_udp_attempt_count);
          }
          // Second, call derived stub function.
          else
          {
            bIsImplemented__ = ReportC2SUdpMessageTrialCount(RemoteId__, RpcHint__, to_server_udp_attempt_count);
          }

          if (!bIsImplemented__)
          {
            Core->ShowNotImplementedRpcWarning(RpcIds::ReportC2SUdpMessageTrialCount, RpcNames::ReportC2SUdpMessageTrialCount());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_)
          {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::ReportC2SUdpMessageTrialCount, RpcNames::ReportC2SUdpMessageTrialCount(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }
    }

    Failure__: ImmutableMessage__.SetPosition(SavedReadPosition__); return false;
    #undef DO_CHECKED__
  }
} // end of namespace NetC2S

} // end of namespace fun
