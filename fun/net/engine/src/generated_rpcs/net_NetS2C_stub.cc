/**
 * Auto-generated by IDL Compiler (2.1.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#include "net_NetS2C_stub.h"
#include "net.h" // _Args, _PArgs

namespace fun {
namespace NetS2C {

  bool Stub::ProcessReceivedMessage(fun::ReceivedMessage& received_msg, void* host_tag) {
    #define DO_CHECKED__(Expr) { if (!(Expr)) goto Failure__; }

    const fun::HostId RemoteId__ = received_msg.remote_id;
    fun::IMessageIn& ImmutableMessage__ = received_msg.unsafe_message;
    const fun::int32 SavedReadPosition__ = ImmutableMessage__.GetPosition();

    fun::RpcHint RpcHint__;
    RpcHint__.relayed = received_msg.relayed;
    RpcHint__.host_tag = host_tag;

    fun::RpcId RpcId__;
    fun::RpcHeader RpcHeader__;
    DO_CHECKED__(fun::LiteFormat::Read(ImmutableMessage__, RpcId__));
    DO_CHECKED__(RpcHeader__.Read(ImmutableMessage__));

    RpcHint__.result_code = RpcHeader__.result_code;
    RpcHint__.error_message = RpcHeader__.error_message;

    switch ((fun::uint32)RpcId__)  {
      case (fun::uint32)RpcIds::P2PGroup_MemberJoin:
      {
          // Declare arguments.
          fun::HostId group_id = fun::HostId_None;
          fun::HostId member_id = fun::HostId_None;
          fun::ByteArray custom_field;
          fun::uint32 event_id = 0;
          fun::ByteArray P2PAESSessionKey;
          fun::ByteArray P2PRC4SessionKey;
          fun::FrameNumber p2p_first_frame_number = (fun::FrameNumber)0;
          fun::Uuid ConnectionTag = fun::Uuid::None;
          bool direct_p2p_enabled = false;
          fun::int32 BindPort = 0;

          // Read arguments.
          if (RpcHint__.result_code == 0) {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, group_id));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, member_id));
            DO_CHECKED__(fun::FlexFormat::ReadBytes(ImmutableMessage__, custom_field));
            DO_CHECKED__(fun::FlexFormat::ReadUInt32(ImmutableMessage__, event_id));
            DO_CHECKED__(fun::FlexFormat::ReadBytes(ImmutableMessage__, P2PAESSessionKey));
            DO_CHECKED__(fun::FlexFormat::ReadBytes(ImmutableMessage__, P2PRC4SessionKey));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, p2p_first_frame_number));
            DO_CHECKED__(fun::FlexFormat::ReadGuid(ImmutableMessage__, ConnectionTag));
            DO_CHECKED__(fun::FlexFormat::ReadBool(ImmutableMessage__, direct_p2p_enabled));
            DO_CHECKED__(fun::FlexFormat::ReadSInt32(ImmutableMessage__, BindPort));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::P2PGroup_MemberJoin, RpcNames::P2PGroup_MemberJoin());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"group_id\":") + fun::ToString(group_id);
            ArgsStr__ += TEXT(",\"member_id\":") + fun::ToString(member_id);
            ArgsStr__ += TEXT(",\"custom_field\":") + fun::ToString(custom_field);
            ArgsStr__ += TEXT(",\"event_id\":") + fun::ToString(event_id);
            ArgsStr__ += TEXT(",\"P2PAESSessionKey\":") + fun::ToString(P2PAESSessionKey);
            ArgsStr__ += TEXT(",\"P2PRC4SessionKey\":") + fun::ToString(P2PRC4SessionKey);
            ArgsStr__ += TEXT(",\"p2p_first_frame_number\":") + fun::ToString(p2p_first_frame_number);
            ArgsStr__ += TEXT(",\"ConnectionTag\":") + fun::ToString(ConnectionTag);
            ArgsStr__ += TEXT(",\"direct_p2p_enabled\":") + fun::ToString(direct_p2p_enabled);
            ArgsStr__ += TEXT(",\"BindPort\":") + fun::ToString(BindPort);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::P2PGroup_MemberJoin, RpcNames::P2PGroup_MemberJoin(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::P2PGroup_MemberJoin, RpcNames::P2PGroup_MemberJoin(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnP2PGroup_MemberJoin) {
            bIsImplemented__ = OnP2PGroup_MemberJoin(RemoteId__, RpcHint__, group_id, member_id, custom_field, event_id, P2PAESSessionKey, P2PRC4SessionKey, p2p_first_frame_number, ConnectionTag, direct_p2p_enabled, BindPort);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = P2PGroup_MemberJoin(RemoteId__, RpcHint__, group_id, member_id, custom_field, event_id, P2PAESSessionKey, P2PRC4SessionKey, p2p_first_frame_number, ConnectionTag, direct_p2p_enabled, BindPort);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::P2PGroup_MemberJoin, RpcNames::P2PGroup_MemberJoin());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::P2PGroup_MemberJoin, RpcNames::P2PGroup_MemberJoin(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::P2PGroup_MemberJoin_Unencrypted:
      {
          // Declare arguments.
          fun::HostId group_id = fun::HostId_None;
          fun::HostId member_id = fun::HostId_None;
          fun::ByteArray custom_field;
          fun::uint32 event_id = 0;
          fun::FrameNumber p2p_first_frame_number = (fun::FrameNumber)0;
          fun::Uuid ConnectionTag = fun::Uuid::None;
          bool direct_p2p_enabled = false;
          fun::int32 BindPort = 0;

          // Read arguments.
          if (RpcHint__.result_code == 0) {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, group_id));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, member_id));
            DO_CHECKED__(fun::FlexFormat::ReadBytes(ImmutableMessage__, custom_field));
            DO_CHECKED__(fun::FlexFormat::ReadUInt32(ImmutableMessage__, event_id));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, p2p_first_frame_number));
            DO_CHECKED__(fun::FlexFormat::ReadGuid(ImmutableMessage__, ConnectionTag));
            DO_CHECKED__(fun::FlexFormat::ReadBool(ImmutableMessage__, direct_p2p_enabled));
            DO_CHECKED__(fun::FlexFormat::ReadSInt32(ImmutableMessage__, BindPort));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::P2PGroup_MemberJoin_Unencrypted, RpcNames::P2PGroup_MemberJoin_Unencrypted());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"group_id\":") + fun::ToString(group_id);
            ArgsStr__ += TEXT(",\"member_id\":") + fun::ToString(member_id);
            ArgsStr__ += TEXT(",\"custom_field\":") + fun::ToString(custom_field);
            ArgsStr__ += TEXT(",\"event_id\":") + fun::ToString(event_id);
            ArgsStr__ += TEXT(",\"p2p_first_frame_number\":") + fun::ToString(p2p_first_frame_number);
            ArgsStr__ += TEXT(",\"ConnectionTag\":") + fun::ToString(ConnectionTag);
            ArgsStr__ += TEXT(",\"direct_p2p_enabled\":") + fun::ToString(direct_p2p_enabled);
            ArgsStr__ += TEXT(",\"BindPort\":") + fun::ToString(BindPort);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::P2PGroup_MemberJoin_Unencrypted, RpcNames::P2PGroup_MemberJoin_Unencrypted(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::P2PGroup_MemberJoin_Unencrypted, RpcNames::P2PGroup_MemberJoin_Unencrypted(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnP2PGroup_MemberJoin_Unencrypted) {
            bIsImplemented__ = OnP2PGroup_MemberJoin_Unencrypted(RemoteId__, RpcHint__, group_id, member_id, custom_field, event_id, p2p_first_frame_number, ConnectionTag, direct_p2p_enabled, BindPort);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = P2PGroup_MemberJoin_Unencrypted(RemoteId__, RpcHint__, group_id, member_id, custom_field, event_id, p2p_first_frame_number, ConnectionTag, direct_p2p_enabled, BindPort);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::P2PGroup_MemberJoin_Unencrypted, RpcNames::P2PGroup_MemberJoin_Unencrypted());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::P2PGroup_MemberJoin_Unencrypted, RpcNames::P2PGroup_MemberJoin_Unencrypted(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::P2PRecycleComplete:
      {
          // Declare arguments.
          fun::HostId peer_id = fun::HostId_None;
          bool bRecycled = false;
          fun::InetAddress internal_addr = fun::InetAddress();
          fun::InetAddress external_addr = fun::InetAddress();
          fun::InetAddress SendAddr = fun::InetAddress();
          fun::InetAddress RecvAddr = fun::InetAddress();

          // Read arguments.
          if (RpcHint__.result_code == 0) {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, peer_id));
            DO_CHECKED__(fun::FlexFormat::ReadBool(ImmutableMessage__, bRecycled));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, internal_addr));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, external_addr));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, SendAddr));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, RecvAddr));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::P2PRecycleComplete, RpcNames::P2PRecycleComplete());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"peer_id\":") + fun::ToString(peer_id);
            ArgsStr__ += TEXT(",\"bRecycled\":") + fun::ToString(bRecycled);
            ArgsStr__ += TEXT(",\"internal_addr\":") + fun::ToString(internal_addr);
            ArgsStr__ += TEXT(",\"external_addr\":") + fun::ToString(external_addr);
            ArgsStr__ += TEXT(",\"SendAddr\":") + fun::ToString(SendAddr);
            ArgsStr__ += TEXT(",\"RecvAddr\":") + fun::ToString(RecvAddr);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::P2PRecycleComplete, RpcNames::P2PRecycleComplete(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::P2PRecycleComplete, RpcNames::P2PRecycleComplete(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnP2PRecycleComplete) {
            bIsImplemented__ = OnP2PRecycleComplete(RemoteId__, RpcHint__, peer_id, bRecycled, internal_addr, external_addr, SendAddr, RecvAddr);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = P2PRecycleComplete(RemoteId__, RpcHint__, peer_id, bRecycled, internal_addr, external_addr, SendAddr, RecvAddr);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::P2PRecycleComplete, RpcNames::P2PRecycleComplete());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::P2PRecycleComplete, RpcNames::P2PRecycleComplete(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::RequestP2PHolepunch:
      {
          // Declare arguments.
          fun::HostId peer_id = fun::HostId_None;
          fun::InetAddress internal_addr = fun::InetAddress();
          fun::InetAddress external_addr = fun::InetAddress();

          // Read arguments.
          if (RpcHint__.result_code == 0) {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, peer_id));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, internal_addr));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, external_addr));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::RequestP2PHolepunch, RpcNames::RequestP2PHolepunch());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"peer_id\":") + fun::ToString(peer_id);
            ArgsStr__ += TEXT(",\"internal_addr\":") + fun::ToString(internal_addr);
            ArgsStr__ += TEXT(",\"external_addr\":") + fun::ToString(external_addr);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::RequestP2PHolepunch, RpcNames::RequestP2PHolepunch(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::RequestP2PHolepunch, RpcNames::RequestP2PHolepunch(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnRequestP2PHolepunch) {
            bIsImplemented__ = OnRequestP2PHolepunch(RemoteId__, RpcHint__, peer_id, internal_addr, external_addr);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = RequestP2PHolepunch(RemoteId__, RpcHint__, peer_id, internal_addr, external_addr);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::RequestP2PHolepunch, RpcNames::RequestP2PHolepunch());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::RequestP2PHolepunch, RpcNames::RequestP2PHolepunch(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::P2P_NotifyDirectP2PDisconnected2:
      {
          // Declare arguments.
          fun::HostId peer_id = fun::HostId_None;
          fun::ResultCode reason = (fun::ResultCode)0;

          // Read arguments.
          if (RpcHint__.result_code == 0) {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, peer_id));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, reason));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::P2P_NotifyDirectP2PDisconnected2, RpcNames::P2P_NotifyDirectP2PDisconnected2());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"peer_id\":") + fun::ToString(peer_id);
            ArgsStr__ += TEXT(",\"reason\":") + fun::ToString(reason);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::P2P_NotifyDirectP2PDisconnected2, RpcNames::P2P_NotifyDirectP2PDisconnected2(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::P2P_NotifyDirectP2PDisconnected2, RpcNames::P2P_NotifyDirectP2PDisconnected2(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnP2P_NotifyDirectP2PDisconnected2) {
            bIsImplemented__ = OnP2P_NotifyDirectP2PDisconnected2(RemoteId__, RpcHint__, peer_id, reason);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = P2P_NotifyDirectP2PDisconnected2(RemoteId__, RpcHint__, peer_id, reason);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::P2P_NotifyDirectP2PDisconnected2, RpcNames::P2P_NotifyDirectP2PDisconnected2());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::P2P_NotifyDirectP2PDisconnected2, RpcNames::P2P_NotifyDirectP2PDisconnected2(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::P2PGroup_MemberLeave:
      {
          // Declare arguments.
          fun::HostId member_id = fun::HostId_None;
          fun::HostId group_id = fun::HostId_None;

          // Read arguments.
          if (RpcHint__.result_code == 0) {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, member_id));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, group_id));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::P2PGroup_MemberLeave, RpcNames::P2PGroup_MemberLeave());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"member_id\":") + fun::ToString(member_id);
            ArgsStr__ += TEXT(",\"group_id\":") + fun::ToString(group_id);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::P2PGroup_MemberLeave, RpcNames::P2PGroup_MemberLeave(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::P2PGroup_MemberLeave, RpcNames::P2PGroup_MemberLeave(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnP2PGroup_MemberLeave) {
            bIsImplemented__ = OnP2PGroup_MemberLeave(RemoteId__, RpcHint__, member_id, group_id);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = P2PGroup_MemberLeave(RemoteId__, RpcHint__, member_id, group_id);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::P2PGroup_MemberLeave, RpcNames::P2PGroup_MemberLeave());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::P2PGroup_MemberLeave, RpcNames::P2PGroup_MemberLeave(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::NotifyDirectP2PEstablish:
      {
          // Declare arguments.
          fun::HostId A0 = fun::HostId_None;
          fun::HostId B0 = fun::HostId_None;
          fun::InetAddress X0 = fun::InetAddress();
          fun::InetAddress Y0 = fun::InetAddress();
          fun::InetAddress Z0 = fun::InetAddress();
          fun::InetAddress W0 = fun::InetAddress();

          // Read arguments.
          if (RpcHint__.result_code == 0) {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, A0));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, B0));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, X0));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, Y0));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, Z0));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, W0));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::NotifyDirectP2PEstablish, RpcNames::NotifyDirectP2PEstablish());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"A0\":") + fun::ToString(A0);
            ArgsStr__ += TEXT(",\"B0\":") + fun::ToString(B0);
            ArgsStr__ += TEXT(",\"X0\":") + fun::ToString(X0);
            ArgsStr__ += TEXT(",\"Y0\":") + fun::ToString(Y0);
            ArgsStr__ += TEXT(",\"Z0\":") + fun::ToString(Z0);
            ArgsStr__ += TEXT(",\"W0\":") + fun::ToString(W0);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::NotifyDirectP2PEstablish, RpcNames::NotifyDirectP2PEstablish(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::NotifyDirectP2PEstablish, RpcNames::NotifyDirectP2PEstablish(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnNotifyDirectP2PEstablish) {
            bIsImplemented__ = OnNotifyDirectP2PEstablish(RemoteId__, RpcHint__, A0, B0, X0, Y0, Z0, W0);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = NotifyDirectP2PEstablish(RemoteId__, RpcHint__, A0, B0, X0, Y0, Z0, W0);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::NotifyDirectP2PEstablish, RpcNames::NotifyDirectP2PEstablish());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::NotifyDirectP2PEstablish, RpcNames::NotifyDirectP2PEstablish(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::ReliablePong:
      {
          // No arguments.

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::ReliablePong, RpcNames::ReliablePong());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->NotifyCallFromStub(RpcIds::ReliablePong, RpcNames::ReliablePong(), TEXT("{}"));
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::ReliablePong, RpcNames::ReliablePong(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnReliablePong) {
            bIsImplemented__ = OnReliablePong(RemoteId__, RpcHint__);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = ReliablePong(RemoteId__, RpcHint__);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::ReliablePong, RpcNames::ReliablePong());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::ReliablePong, RpcNames::ReliablePong(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::EnableIntraLogging:
      {
          // No arguments.

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::EnableIntraLogging, RpcNames::EnableIntraLogging());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->NotifyCallFromStub(RpcIds::EnableIntraLogging, RpcNames::EnableIntraLogging(), TEXT("{}"));
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::EnableIntraLogging, RpcNames::EnableIntraLogging(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnEnableIntraLogging) {
            bIsImplemented__ = OnEnableIntraLogging(RemoteId__, RpcHint__);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = EnableIntraLogging(RemoteId__, RpcHint__);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::EnableIntraLogging, RpcNames::EnableIntraLogging());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::EnableIntraLogging, RpcNames::EnableIntraLogging(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::DisableIntraLogging:
      {
          // No arguments.

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::DisableIntraLogging, RpcNames::DisableIntraLogging());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->NotifyCallFromStub(RpcIds::DisableIntraLogging, RpcNames::DisableIntraLogging(), TEXT("{}"));
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::DisableIntraLogging, RpcNames::DisableIntraLogging(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnDisableIntraLogging) {
            bIsImplemented__ = OnDisableIntraLogging(RemoteId__, RpcHint__);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = DisableIntraLogging(RemoteId__, RpcHint__);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::DisableIntraLogging, RpcNames::DisableIntraLogging());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::DisableIntraLogging, RpcNames::DisableIntraLogging(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::NotifyUdpToTcpFallbackByServer:
      {
          // No arguments.

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::NotifyUdpToTcpFallbackByServer, RpcNames::NotifyUdpToTcpFallbackByServer());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->NotifyCallFromStub(RpcIds::NotifyUdpToTcpFallbackByServer, RpcNames::NotifyUdpToTcpFallbackByServer(), TEXT("{}"));
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::NotifyUdpToTcpFallbackByServer, RpcNames::NotifyUdpToTcpFallbackByServer(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnNotifyUdpToTcpFallbackByServer) {
            bIsImplemented__ = OnNotifyUdpToTcpFallbackByServer(RemoteId__, RpcHint__);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = NotifyUdpToTcpFallbackByServer(RemoteId__, RpcHint__);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::NotifyUdpToTcpFallbackByServer, RpcNames::NotifyUdpToTcpFallbackByServer());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::NotifyUdpToTcpFallbackByServer, RpcNames::NotifyUdpToTcpFallbackByServer(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::NotifySpeedHackDetectorEnabled:
      {
          // Declare arguments.
          bool bEnabled = false;

          // Read arguments.
          if (RpcHint__.result_code == 0) {
            DO_CHECKED__(fun::FlexFormat::ReadBool(ImmutableMessage__, bEnabled));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::NotifySpeedHackDetectorEnabled, RpcNames::NotifySpeedHackDetectorEnabled());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"bEnabled\":") + fun::ToString(bEnabled);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::NotifySpeedHackDetectorEnabled, RpcNames::NotifySpeedHackDetectorEnabled(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::NotifySpeedHackDetectorEnabled, RpcNames::NotifySpeedHackDetectorEnabled(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnNotifySpeedHackDetectorEnabled) {
            bIsImplemented__ = OnNotifySpeedHackDetectorEnabled(RemoteId__, RpcHint__, bEnabled);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = NotifySpeedHackDetectorEnabled(RemoteId__, RpcHint__, bEnabled);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::NotifySpeedHackDetectorEnabled, RpcNames::NotifySpeedHackDetectorEnabled());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::NotifySpeedHackDetectorEnabled, RpcNames::NotifySpeedHackDetectorEnabled(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::ShutdownTcpAck:
      {
          // No arguments.

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::ShutdownTcpAck, RpcNames::ShutdownTcpAck());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->NotifyCallFromStub(RpcIds::ShutdownTcpAck, RpcNames::ShutdownTcpAck(), TEXT("{}"));
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::ShutdownTcpAck, RpcNames::ShutdownTcpAck(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnShutdownTcpAck) {
            bIsImplemented__ = OnShutdownTcpAck(RemoteId__, RpcHint__);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = ShutdownTcpAck(RemoteId__, RpcHint__);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::ShutdownTcpAck, RpcNames::ShutdownTcpAck());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::ShutdownTcpAck, RpcNames::ShutdownTcpAck(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::RequestAutoPrune:
      {
          // No arguments.

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::RequestAutoPrune, RpcNames::RequestAutoPrune());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->NotifyCallFromStub(RpcIds::RequestAutoPrune, RpcNames::RequestAutoPrune(), TEXT("{}"));
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::RequestAutoPrune, RpcNames::RequestAutoPrune(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnRequestAutoPrune) {
            bIsImplemented__ = OnRequestAutoPrune(RemoteId__, RpcHint__);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = RequestAutoPrune(RemoteId__, RpcHint__);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::RequestAutoPrune, RpcNames::RequestAutoPrune());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::RequestAutoPrune, RpcNames::RequestAutoPrune(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::RenewP2PConnectionState:
      {
          // Declare arguments.
          fun::HostId peer_id = fun::HostId_None;

          // Read arguments.
          if (RpcHint__.result_code == 0) {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, peer_id));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::RenewP2PConnectionState, RpcNames::RenewP2PConnectionState());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"peer_id\":") + fun::ToString(peer_id);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::RenewP2PConnectionState, RpcNames::RenewP2PConnectionState(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::RenewP2PConnectionState, RpcNames::RenewP2PConnectionState(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnRenewP2PConnectionState) {
            bIsImplemented__ = OnRenewP2PConnectionState(RemoteId__, RpcHint__, peer_id);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = RenewP2PConnectionState(RemoteId__, RpcHint__, peer_id);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::RenewP2PConnectionState, RpcNames::RenewP2PConnectionState());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::RenewP2PConnectionState, RpcNames::RenewP2PConnectionState(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::NewDirectP2PConnection:
      {
          // Declare arguments.
          fun::HostId peer_id = fun::HostId_None;

          // Read arguments.
          if (RpcHint__.result_code == 0) {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, peer_id));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::NewDirectP2PConnection, RpcNames::NewDirectP2PConnection());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"peer_id\":") + fun::ToString(peer_id);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::NewDirectP2PConnection, RpcNames::NewDirectP2PConnection(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::NewDirectP2PConnection, RpcNames::NewDirectP2PConnection(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnNewDirectP2PConnection) {
            bIsImplemented__ = OnNewDirectP2PConnection(RemoteId__, RpcHint__, peer_id);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = NewDirectP2PConnection(RemoteId__, RpcHint__, peer_id);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::NewDirectP2PConnection, RpcNames::NewDirectP2PConnection());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::NewDirectP2PConnection, RpcNames::NewDirectP2PConnection(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::RequestMeasureSendSpeed:
      {
          // Declare arguments.
          bool bEnabled = false;

          // Read arguments.
          if (RpcHint__.result_code == 0) {
            DO_CHECKED__(fun::FlexFormat::ReadBool(ImmutableMessage__, bEnabled));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::RequestMeasureSendSpeed, RpcNames::RequestMeasureSendSpeed());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"bEnabled\":") + fun::ToString(bEnabled);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::RequestMeasureSendSpeed, RpcNames::RequestMeasureSendSpeed(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::RequestMeasureSendSpeed, RpcNames::RequestMeasureSendSpeed(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnRequestMeasureSendSpeed) {
            bIsImplemented__ = OnRequestMeasureSendSpeed(RemoteId__, RpcHint__, bEnabled);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = RequestMeasureSendSpeed(RemoteId__, RpcHint__, bEnabled);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::RequestMeasureSendSpeed, RpcNames::RequestMeasureSendSpeed());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::RequestMeasureSendSpeed, RpcNames::RequestMeasureSendSpeed(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::S2C_RequestCreateUdpSocket:
      {
          // Declare arguments.
          fun::NamedInetAddress ServerUdpAddr = fun::NamedInetAddress();

          // Read arguments.
          if (RpcHint__.result_code == 0) {
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, ServerUdpAddr));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::S2C_RequestCreateUdpSocket, RpcNames::S2C_RequestCreateUdpSocket());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"ServerUdpAddr\":") + fun::ToString(ServerUdpAddr);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::S2C_RequestCreateUdpSocket, RpcNames::S2C_RequestCreateUdpSocket(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::S2C_RequestCreateUdpSocket, RpcNames::S2C_RequestCreateUdpSocket(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnS2C_RequestCreateUdpSocket) {
            bIsImplemented__ = OnS2C_RequestCreateUdpSocket(RemoteId__, RpcHint__, ServerUdpAddr);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = S2C_RequestCreateUdpSocket(RemoteId__, RpcHint__, ServerUdpAddr);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::S2C_RequestCreateUdpSocket, RpcNames::S2C_RequestCreateUdpSocket());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::S2C_RequestCreateUdpSocket, RpcNames::S2C_RequestCreateUdpSocket(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }

      case (fun::uint32)RpcIds::S2C_CreateUdpSocketAck:
      {
          // Declare arguments.
          bool bOk = false;
          fun::NamedInetAddress ServerUdpAddr = fun::NamedInetAddress();

          // Read arguments.
          if (RpcHint__.result_code == 0) {
            DO_CHECKED__(fun::FlexFormat::ReadBool(ImmutableMessage__, bOk));
            DO_CHECKED__(EngineTypes_UserTypeHandlers::Read(ImmutableMessage__, ServerUdpAddr));
          }

          Core->PostCheckReadMessage(ImmutableMessage__, RpcIds::S2C_CreateUdpSocketAck, RpcNames::S2C_CreateUdpSocketAck());

          // NotifyCallFromStub
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            fun::String ArgsStr__ = TEXT("{");
            ArgsStr__ += TEXT("\"bOk\":") + fun::ToString(bOk);
            ArgsStr__ += TEXT(",\"ServerUdpAddr\":") + fun::ToString(ServerUdpAddr);
            ArgsStr__ += TEXT("}");

            Core->NotifyCallFromStub(RpcIds::S2C_CreateUdpSocketAck, RpcNames::S2C_CreateUdpSocketAck(), ArgsStr__);
          }

          // Before RPC invocation.
          fun::uint32 InvocationTime__ = 0;
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->BeforeRpcInvocation(fun::BeforeRpcSummary(RpcIds::S2C_CreateUdpSocketAck, RpcNames::S2C_CreateUdpSocketAck(), RemoteId__, host_tag));
            InvocationTime__ = fun::Clock::Milliseconds();
          }

          bool bIsImplemented__ = false;
          // First, try function object.
          if ((bool)OnS2C_CreateUdpSocketAck) {
            bIsImplemented__ = OnS2C_CreateUdpSocketAck(RemoteId__, RpcHint__, bOk, ServerUdpAddr);
          }
          // Second, call derived stub function.
          else {
            bIsImplemented__ = S2C_CreateUdpSocketAck(RemoteId__, RpcHint__, bOk, ServerUdpAddr);
          }

          if (!bIsImplemented__) {
            Core->ShowNotImplementedRpcWarning(RpcIds::S2C_CreateUdpSocketAck, RpcNames::S2C_CreateUdpSocketAck());
          }

          // After RPC invocation.
          if (notify_call_from_stub_enabled_ && !engine_specific_only_) {
            Core->AfterRpcInvocation(fun::AfterRpcSummary(RpcIds::S2C_CreateUdpSocketAck, RpcNames::S2C_CreateUdpSocketAck(), RemoteId__, host_tag, fun::Clock::Milliseconds() - InvocationTime__));
          }

          return true;
      }
    }

    Failure__: ImmutableMessage__.SetPosition(SavedReadPosition__); return false;
    #undef DO_CHECKED__
  }
} // end of namespace NetS2C

} // end of namespace fun
