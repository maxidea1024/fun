/**
 * Auto-generated by IDL Compiler (1.0.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#pragma once

#include "FUN.h"
#include "dump_types.h"

#define IDL_BEGIN_GLOBAL_NAMESPACE }}
#define IDL_END_GLOBAL_NAMESPACE namespace fun { namespace Dump {

namespace fun { namespace Dump {

//==============================================================================
// Service C2S
//==============================================================================

namespace C2S
{
  struct CC2S_Chunk_Args
  {
    // arguments.
    fun::ByteArray Chunk;

    // Construction
    inline CC2S_Chunk_Args() {}

    // Reader
    bool Read(fun::IMessageIn& Input__)
    {
      #define DO_CHECKED__(Expr) { if (!(Expr)) return false; }
      DO_CHECKED__(fun::FlexFormat::ReadBytes(Input__, Chunk));
      return true;
      #undef DO_CHECKED__
    }

    // ToString(Json style for diagnostics)
    inline fun::String ToString() const
    {
      fun::String result = TEXT("{");
      result << TEXT("\"Chunk\":") << fun::ToString(Chunk);
      result << TEXT("}");
      return result;
    }
  };

  struct CC2S_Chunk_PArgs
  {
    // arguments.
    const fun::ByteArray* Chunk;

    // Construction
    inline CC2S_Chunk_PArgs(const fun::ByteArray* Chunk_)
      : Chunk(Chunk_)
    {}

    // Writer
    inline void Write(fun::IMessageOut& Output__)
    {
      fun::FlexFormat::WriteBytes(Output__, *Chunk);
    }

    // ToString(Json style for diagnostics)
    inline fun::String ToString() const
    {
      fun::String result = TEXT("{");
      result << TEXT("\"Chunk\":") << fun::ToString(*Chunk);
      result << TEXT("}");
      return result;
    }
  };
} // end of namespace C2S


//==============================================================================
// Service S2C
//==============================================================================

namespace S2C
{
} // end of namespace S2C


}} // end of namespace fun::Dump

#undef IDL_BEGIN_GLOBAL_NAMESPACE
#undef IDL_END_GLOBAL_NAMESPACE
